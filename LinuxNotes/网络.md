[TOC]

# 认识网络的结构

> 网络本质是传输数据，比如我们在刷抖音而抖音上的视频资源是怎么来的？我们是通过网络协议栈发送了一个获取视频资源的请求，当抖音总部的服务器收到这个请求会根据请求来计算等操作来获取你想要的操作，当这些执行完了服务器通过网络协议栈来发送给你，这时你就收到了抖音上的视频资源。
>
> ![image-20221017174210382](https://raw.githubusercontent.com/ls02/Image/img/202210202142672.png)

## 什么是网络协议栈？

> 网络协议栈里面有五层，其中有物理层、数据链路层、网络层、传输层和应用层；
>
> + 物理层和数据链路层
>
>   主要是负责完成数据真正发送的过程；
>
> + 网络层
>
>   主要是负责完成数据转发，数据去那的问题；
>
> + 传输层
>
>   主要是负责处理数据在传输过程中遇到的问题，保证数据去那的可靠性；
>
> + 应用层
>
>   主要负责处理业务细节，比如：我想获取某个服务器上的资源或拿到某个服务器上的网页。
>
> ![image-20221017180006924](https://raw.githubusercontent.com/ls02/Image/img/202210181056268.png)
>
> **层状结构的本质：** 软件工程上面的解耦，层与层之间只有互相调动的关系，这样增加了代码的可维护性和可扩展性

## 网络协议栈在OS上的结构

![image-20221018230935029](https://raw.githubusercontent.com/ls02/Image/img/202210182309120.png)



# 网络发展

## 局域网

> **独立模式：** 计算机之间是相互独立的
>
> ![image-20221018221900834](https://raw.githubusercontent.com/ls02/Image/img/202210182219951.png)
>
> 早期的计算机通常是知名高校实验室和国家单位才有的东西，而早期人们利用计算机完成一些及计算任务，通常都是划分几个人完成不同模块如：A、B、C和D。完成了某种计算任务它们需要把数据都拷贝到某一台计算机上才能整体完成，而这样拷贝的过程很耗费时间同时也限制了地点，后来有人提出可以不可以用一个根线将它们链接起来，这样做好相关计算任务的时候就不需要都去把数据拷贝到某台机器上了，由此诞生了局域网（LAN）。
>
> **网络互联:**  多台计算机连接在一起, 完成数据共享;  
>
> ![image-20221018221954962](https://raw.githubusercontent.com/ls02/Image/img/202210182219967.png)
>
> 而后来随着技术的发展计算机有更多的人使用计算机，局域网（LAN）也因此越来越多，但是每个局域网之间又想通信这时广域网（WAN）诞生了。
>
> **广域网WAN:**  将远隔千里的计算机都连在一起; ，广域网本质就是一个包含多个局域网的大型局域网 。
>
> ![image-20221018222355116](https://raw.githubusercontent.com/ls02/Image/img/202210182223556.png)
>
> ![image-20221018222421413](https://raw.githubusercontent.com/ls02/Image/img/202210182224393.png)

## 网络协议知识

### 认识协议

> 协议：本质是一种约定
>
> 不同之间的计算机是怎么完成通信的？当然是依靠协议了，就像我们中国人之间是如何完成通信的也是通过语言来完成而我们中国使用的语言是汉语，那么汉语是不是一种约定？如果你不懂汉语我们是无法完成交流的，而计算机之间也是如此，如果没有某个约定那么不同计算机之间是无法通信的因为通信的信息无法解读自然就完成不了通信了。
>
> 而计算机之间的传输媒介是光信号和电信号. 通过 "频率" 和 "强弱" 来表示 0 和 1 这样的信息. 要想传递各种不同的信息, 就需要约定好双方的数据格式.  
>
> ![image-20221018222844896](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20221018222844896.png)
>
> 那么计算机由不同厂商生产，那么为了不同厂商之间的计算机也能通信，我们需要一种协议而这种协议谁来定义的呢？一般定义这种协议的都是该领域的佼佼者，就像秦始皇统一汉字和语言一样。
>
> 当所有人都按照协议来通信，那么不管你是那家厂商生产的只要遵守约定就能完成通信，而这种协议也叫网络协议。

## OSI七层模型

> + OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型，是一个逻辑上的定义和规范;  
> + 把网络从逻辑上分为了7层. 每一层都有相关、相对应的物理设备，比如路由器，交换机;  
> + OSI 七层模型是一种框架性的设计方法，其最主要的功能使就是帮助不同类型的主机实现数据传输;  
> + 它的最大优点是将服务、接口和协议这三个概念明确地区分开来，概念清楚，理论也比较完整. 通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯;  
>
> ![image-20221018225902883](https://raw.githubusercontent.com/ls02/Image/img/202210182259209.png)

## TCP/IP五层(或四层)模型  

> TCP/IP是一组协议的代名词，它还包括许多协议，组成了TCP/IP协议簇.
>
> TCP/IP通讯协议采用了5层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求.  
>
> + **物理层:**  负责光/电信号的传递方式. 比如现在以太网通用的网线(双绞 线)、早期以太网采用的的同轴电缆(现在主要用于有线电视)、光纤, 现在的wifi无线网使用电磁波等都属于物理层的概念。物理层的能力决定了最大传输速率、传输距离、抗干扰性等. 集线器(Hub)工作在物理层.  
> + **数据链路层:**  负责设备之间的数据帧的传送和识别. 例如网卡设备的驱动、帧同步(就是说从网线上检测到什么信号算作新帧的开始)、冲突检测(如果检测到冲突就自动重发)、数据差错校验等工作. 有以太网、令牌环网, 无线LAN等标准. 交换机(Switch)工作在数据链路层.  
> + **网络层:**  负责地址管理和路由选择. 例如在IP协议中, 通过IP地址来标识一台主机, 并通过路由表的方式规划出两台主机之间的数据传输的线路(路由).路由器(Router)工作在网路层.  
> + **传输层:**  负责两台主机之间的数据传输. 如传输控制协议 (TCP), 能够确保数据可靠的从源主机发送到目标主机.  
> + **应用层:**  负责应用程序间沟通，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等. 我们的网络编程主要就是针对应用层.  

![image-20221018230050387](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20221018230050387.png)



> 物理层我们考虑的比较少. 因此很多时候也可以称为 TCP/IP四层模型 ;
>
> + 对于一台主机, 它的操作系统内核实现了从传输层到物理层的内容  
> + 对于一台路由器, 它实现了从网络层到物理层;  
> + 对于一台交换机, 它实现了从数据链路层到物理层;  
> + 对于集线器, 它只实现了物理层;  
>
> 但是并不绝对. 很多交换机也实现了网络层的转发; 很多路由器也实现了部分传输层的内容(比如端口转发);  



## 网络传输基本流程图

### 网络传输流程图

同一个网段内的两台主机进行文件传输  

![image-20221018232056791](https://raw.githubusercontent.com/ls02/Image/img/202210182320723.png)



### TCP/IP通讯过程

![image-20221019135518248](https://raw.githubusercontent.com/ls02/Image/img/202210191355201.png)

那么我们是如何把一个数据发给另一台机器上呢？我们这时先在应用层把数据打包好，发给传输层传输层，打包好再以此往下直到链路层才开始真正的数据发送，发送的这个数据在链路层叫做数据帧，而另一台机器通过以太协议来接收数据帧，此时数据帧会被解包把根据当前层取出对应的数据包取完之后接着往上发送接着解包直到应用层才会拿到相应的数据。

#### 什么是数据帧？

从链路层发出的数据叫数据帧而数据帧是一个结构，里面存放了每一层打包好的数据。

![image-20221019141052644](https://raw.githubusercontent.com/ls02/Image/img/202210191437645.png)

数据帧本质是一个结构体里面存放了每一层的协议的报头，而报头的数据也是一种结构来存储的。

**如下：**

```c
struct cmd {
    int code;
    int data;
}
```

#### 通讯打包和解包的过程

![image-20221019141621820](https://raw.githubusercontent.com/ls02/Image/img/202210191437595.png)

解包是如何解的呢？每一层解包都会找到对应的包来解，而当前层是怎么知道那个是它要解的包那个是它不要的包？自己要处理的报头区间叫做有效载荷，自己不处理的叫做无效载荷。

![image-20221019142746848](https://raw.githubusercontent.com/ls02/Image/img/202210191437840.png)

当前层如何如何得知报头和有效载荷之间的分割？

**协议共性：** 每个报头都有规定的大小，同时也有相应的字段，常规的就是这两种方法。

1. 定长报头
2. 自定义描述字段

那么我们如何知道将有效载荷交付给上一层的那个协议呢？

**协议共性：** 几乎所有的协议报头中都包含一个字段，表名我们需要把有效载荷交付给上层的那个协议。

加入该协议大小是60字节那么它的结构应该是这样的。

```c
struct ip_header {
    int header_length;
    int load_length;
   
    int type;//表示要交付上一层的协议，用数字表示
}
```

### 数据包装和分用

> + 不同的协议层对数据包有不同的称谓,在传输层叫做段(segment),在网络层叫做数据报 (datagram),在链路层叫做帧(frame).  
> + 应用层数据通过协议栈发到网络上时,每层协议都要加上一个数据首部(header),称为封装(Encapsulation).  
> + 首部信息中包含了一些类似于首部有多长, 载荷(payload)有多长, 上层协议是什么等信息.  
> + 数据封装成帧后发到传输介质上,到达目的主机后每层协议再剥掉相应的首部, 根据首部中的 "上层协议字段" 将数据交给对应的上层协议处理.  

**下图为数据封装的过程  :**

![image-20221019143709317](https://raw.githubusercontent.com/ls02/Image/img/202210191437591.png)

**下图为数据分用的过程  :**

![image-20221019143723962](https://raw.githubusercontent.com/ls02/Image/img/202210191437036.png)



## 网络中的地址管理

## 认识IP地址

> IP协议有两个版本, IPv4和IPv6. 我们整个的课程, 凡是提到IP协议, 没有特殊说明的, 默认都是指IPv4  
>
> + IP地址是在IP协议中, 用来标识网络中不同主机的地址;  
> + 对于IPv4来说, IP地址是一个4字节, 32位的整数;  
> + 我们通常也使用 "点分十进制" 的字符串表示IP地址, 例如 192.168.0.1 ; 用点分割的每一个数字表示一个字节, 范围是 0 - 255;  

## 认识MAC地址  

> + MAC地址用来识别数据链路层中相连的节点  
> + 长度为48位, 及6个字节. 一般用16进制数字加上冒号的形式来表示(例如: 08:00:27:03:fb:19)  
> + 在网卡出厂时就确定了, 不能修改. mac地址通常是唯一的(虚拟机中的mac地址不是真实的mac地址, 可能会冲突; 也有些网卡支持用户配置mac地址)  

# UDP/TCP

## UDP协议

+ 传输层

+ 无链接

  知道对端的IP和端口号就能直接传输，不需要建立链接

+ 不可靠

  没有确认应答机制，没有重传机制，如果因为网络故障该段无法发送到对方，UDP协议也不会给应用层返回任何错误信息

+ 面向数据报

  不能够灵活的控制读写数据的次数和数量。

### UDP协议段格式

![image-20230220175123412](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20230220175123412.png)

> + 16位UDP长度表示整个数据报（UDP首部+UDP数据）的最大长度
> + 如果校验和出错就会直接丢弃



### UDP缓冲区

> + UDP没有真正意义上的发送缓冲区，调用sendto会直接交给内核，由内核将数据传给网络层协议进行后续的传输动作。
> + UDP具有接收缓冲区，但是这个接收换抽取不能保证收到的UDP报的顺序和发送UDP报的顺序一直，如果缓冲区满了，在达到的UDP数据就会被丢弃。

### UDP使用注意事项

我们注意到，UDP协议首部中有一个16位的最大长度，也就是说一个UDP能传输的最大数据是64k（包含UDP首部）

## TCP协议

+ 传输层
+ 面向链接
+ 可靠
+ 面向字节流

### TCP协议段格式

![image-20230220180128738](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20230220180128738.png)

#### TCP确认应答机制

> 当A主机向B主机发送数据，那么A主机的32位序号就是1，B主机收到了数据，那么它会进行应答，它会往确认序号填写2表示1已经收到请发2号数据。

#### 32位序号和32位确认序号

> 32位序号和确认序号使用来保证可靠性，而为什么要用两个字段而不是用一个字段，因为TCP是全双工的我在应答你的同时也有可能再发送新的数据，所以就有两个字段。

#### 16位窗口大小

> 16位窗口大小是接收方来表示自己当前接收缓冲区能容纳的大小。

#### TCP流量控制

> 流量控制会根据16位窗口大小来传输相应的数据量，如果接收方容量变少那么滑动窗口的大小也相应减少，接收方容量变大则相应的增加传输量。

#### 六个标志位

> 是士大夫

+ ACK

  ACK表示自己是确认报文.

+ SYN

  SYN表示是链接建立的请求

+ RST

  RST表示重置链接异常

+ PSH

  PSH表示让接收方尽快将接收缓冲区的数据尽快交付给应用层

+ URG

  URG表示该报文携带了紧急数据需要优先被处理

+ FIN

  FIN表示断开链接请求。

#### 十六位紧急指针

> 十六位紧急指针只能传输一个字节

### 三次握手

![image-20230220180748166](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20230220180748166.png)

#### 为什么是三次握手而不是四次或者两次？

> 1. 确认双方主机网络是否正常
> 2. 验证全双工，三次握手是能看到双方都有收发的最小的次数

### 四次挥手

![image-20230220181032355](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20230220181032355.png)

> 四次挥手是协商断开链接的最小次数

### 超时重传

![image-20230220181209040](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20230220181209040.png)

> + 主机A发送数据给B之后，可能因为网络拥堵等原因，数据无法到达主机B
> + 如果主机A在一个特定的时间间隔内没有收到B发来的确认应答，就会进行重发。

但是，主机A未收到B发来的确认应答，也可能是因为ACK丢失了。

![image-20230220181332913](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20230220181332913.png)

因此主机B会收到很多重复数据，那么TCP协议需要能够识别出那些包是重复的包，并且把重复的丢弃掉。

那么，如果超时的时间如何确定？

> + 最理想的情况下，找到一个最小的时间，保证确认应答一定能在这个时间内返回。
> + 但是这个时间长短是由差异的，会受到当前网络状态影响从而有差以的，所以TCP会动态计算重传的时间。
> + 如果超时时间设的太长会影响整体重传效率。
> + 如果超时时间设的太短，有频繁的发重复包

TCP为了保证无论在任何环境下都能比较高性能的通信，因此会动态计算这个最大超时时间。

> + Linux中（BSD Unix和Windows也是如此）超时以500ms为一个单位，每次判定超时重发的超时时间都是500ms的整数倍也就是500^n次方（从n从1开始随之增大）
> + 如果重发一次后，仍然得不到应答，等待2*500ms后在进行重传。
> + 如果仍然得不到应答，等待4*500ms进行重传，以此类推，以指数形式递增。
> + 累积到一定的重传次数，TCP认为网络或者对端主机出现异常，强制关闭连接。

### 滑动窗口

> 如果按照TCP之前的约定，没收到一条序列号都要发回一个应答序列号的话，那么传输效率回非常低，所以为了提高效率，TCP引入了滑动窗口。
>
> 滑动窗口的三个特点：
>
> 1. 已发送完且应答的数据段
> 2. 正在发送或已发送未应答的数据段
> 3. 待发送的数据段
>
> 滑动窗口不用等待应答就能一直发大量的数据（窗口的最大值），而当滑动窗口内的数据发完之后那么会等接收方的通知，如果接收方只会应答了一个数据，中间的数据都没应答那么发送方会认为全都接收到了。

#### 快重传

> 当滑动窗口发送的大量数据有产生丢包，接收端一直发送101，那么发送端会快速重传101前面的所有数据，当这个数据发完之后接收端发了一个701说明701前面的所有数据都接受到了，这个行为我们叫快速重传。

#### 流量控制

> 当发送端发送大量的数据把接收端的缓冲区打满了，那么这个时候还继续发送回产生丢包，因为TCP会根据接收方的处理能力来控制发送端的速度，这就叫流量控制。

### 拥塞控制

> TCP有了滑动窗口可以快速的发送大量数据，但是如果在一开始就发送大量的数据可能会引发问题。
>
> 因为有很多计算机都是在用TCP协议进行网络通信，那么但大部分主机都进行大量的数据发送会导致网络拥堵，而如果继续发送的话会导致网络雪上加霜，为了避免这个问题，TCP引入了man'qi'd

