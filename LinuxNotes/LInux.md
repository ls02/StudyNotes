[TOC]

---



# Linux背景介绍

## 发展史

你可能要问Linux是怎么诞生的？它是怎么发展的？这里简要介绍Linux的发展史，要说Linux还得先从Unix先说起。

### Unix发展史

> + 1968年，一些来自通用电器公司、贝尔实验室和麻省理工学院的研究人员开发了一个名叫Multics的特殊操作系统。Multics在多任务文件管理和用户连接中综合了许多新概念.
>
> + 1969－1970年，AT&T的贝尔实验室研究人员Ken Tompson和Dennis Ritchie，在采用很多Multics特点的基础上开发了UINX系统。它运行在小型机上，满足了系统对科研环境的要求。从产生开始，UNIX就是一个有价值的、高效的、多用户和多任务的操作系统。
>
> + UNIX从满足个人的设计需求开始，逐步成长为由许多不同开发商所支持的标准软件产品。
>
> + 第一个UNIX版本是免费给许多知名大学的计算机系使用的。
>
> + 1972年，贝尔实验室开始发放商业版本，并且给不同的用户授权使用这个系统，使用者之一是加州大学伯克莱分校的计算机系。伯克莱给系统增加了许多新的特点，后来成为了标准。
> + 1975年伯克莱由下属部门BSD发行了自己的UNIX版本。UNIX的BSD版本成为AT&T贝尔实验室版本的主要竞争者，而其它的独立开发出的UNIX版本也开始萌生。
> + 1980年微软公司开发了叫做Xenix的UNIX PC版本。AT&T发行了第一个商业版本。名叫System Ⅲ，后来被成为对商用软件产品良好支持的System Ⅴ所替代。
> + 同时UNIX的BSD版本不断发展，在70年代末期，BSD UNIX成为了国防部的高科技研究机构科研项目的基础。其结果，伯克莱发行了一个叫做BSD Release 4.2的有效版本。
> + 它包括了高级的文件管理器和基于TCP/IP网络协议的网络特点。现在TCP/IP被Internet所使用。BSD Release4.2被许多厂商所采用，例如SUN Microsystem。
> + UNIX不同版本的出现导致了UNIX标准的需要，软件开发商不知道他们的程序运行在哪些版本上比较合适.
> + 到80年代中期，两个竞争的标准出现了，一个是基于AT&T的UNIX版本，另一个是BSD版本。在今天的书店里你能发现分别适用于这两个版本的不同的UNIX的书，一些是System V，另一些集中在BSD UNIX.
> + AT&T建立了一个叫UNIX系统实验室的新组织，它的作用就是综合UNIX的不同版本，集中开发一个标准系统。
> + 1991年，UNIX综合实验室综合了System V Release3，SUN OS和Xenix的所有特点，发行了System V Release4。为了与System V Release 4 竞争，一些其它公司，如IBM和惠普Open Software Foundation（OSF）去产生自己的UNIX标准版本，继而出现了两个标准商业版本OSF版本和System Release 4。
> + 1993年，AT&T把它的UNIX转卖给Novell公司。UNIX系统实验室成为了Novell的UNIX系统小组的一部分。Novell发行了基于System V Release 4的自己的UNIX版本UNIXWare，它可以和Novell公司的Netware系统相联。SUN公司已经把System V Release 4 融进了它的SUN OS，发行了Solaris。两个相互竞争的UNIX使用的图形用户界面（一个叫Motif，另一个叫Openlook），已经合并为一个新的工作平台标准，叫做通用平台环境CDE）。



### Linux发展史

> + 1991年10月5日，赫尔辛基大学的一名研究生Linus Benedict Torvalds在一个Usenet新闻组
>
>   （comp.os.minix）中宣布他编制出了一种类似UNIX的小操作系统，叫Linux。新的操作系统是受到另一
>
>   个UNIX的小操作系统——Minix的启发，该系统是由一名叫Andrew S Tanenbaum的教师开发的。读者也
>
>   许猜想所发布的这个系统应该是Linux的0.01版本，实际上不是这样。真正的Linux 0.01版本并没有被发布，原因是0.01版本不实用。Linus仅仅在第一个Linux的FTP站点（ftp://nic.funet.fifi）上提供过这个版本的的源代码。
>
> + Torvalds于10月5日发布的这个Linux版本被称为0.02版，它能够运行GNU Bourne Again Shell(bash)和GNU的 C编译程序（gcc）以及为数不多的其它语言。Torvalds绝对没有想到他设想的一种能够针对高级业余爱好者和黑客们的操作系统已经产生，这就是人们所称的Linux。
>
> + Linux发布时的版本是0.02，后来又有0.03版，然后又跳到0.10版。因为世界各地越来越多的程序员都开始开发Linux，它已经达到0.95版。这就意味着正是公布1.0版本的时间已经为期不远了。正式的1.0版本是在1994年公布的

![image-20211207131930488](https://cdn.jsdelivr.net/gh/ls02/Image/img/202210272233834.png)

![image-20211207133337979](https://cdn.jsdelivr.net/gh/ls02/Image/img/202210272233004.png)

# 开源

> + Linux是一种自由和开放源代码的类UNIX操作系统，该操作系统的内核由林纳斯托瓦兹在1991年首次发
>
>   布，之后，在加上用户空间的应用程序之后，就成为了Linux操作系统。严格来讲，Linux只是操作系统内
>
>   核本身，但通常采用“Linux内核”来表达该意思。而Linux则常用来指基于Linux内核的完整操作系统，它
>
>   包括GUI组件和许多其他实用工具。
>
> + GNU通用公共许可协议（GNU General Public License，简称GNU GPL或GPL），是一个广泛被使用的自由软件许可协议条款，最初由理查德斯托曼为GNU计划而撰写，GPL给予了计算机程序自由软件的定义， 任何基于GPL软件开发衍生的产品在发布时必须采用GPL许可证方式，且必须公开源代码.
>
> + Linux是自由软件和开放源代码软件发展中最著名的例子。只要遵循GNU通用公共许可证，任何个人和机构都可以自由地使用Linux的所有底层源代码，也可以自由地修改和再发布。随着Linux操作系统飞速发展，各种集成在Linux上的开源软件和实用工具也得到了应用和普及，因此，Linux也成为了开源软件的代名词。

# LInux官网

> + [kernel官网](https://www.kernel.org/)

# 企业应用现状

> + Linux在服务器领域的发展
>
>   随着开源软件在世界范围内影响力日益增强，Linux服务器操作系统在整个服务器操作系统市场格局中占
>
>   据了越来越多的市场份额，已经形成了大规模市场应用的局面。并且保持着快速的增长率。尤其在政府、
>
>   金融、农业、交通、电信等国家关键领域。此外，考虑到Linux的快速成长性以及国家相关政策的扶持力
>
>   度，Linux服务器产品一定能够冲击更大的服务器市场。
>
>   据权威部门统计，目前Linux在服务器领域已经占据75%的市场份额，同时，Linux在服务器市场的迅速崛
>
>   起，已经引起全球IT产业的高度关注，并以强劲的势头成为服务器操作系统领域中的中坚力量。
>
> + Linux在桌面领域的发展
>
>   近年来，特别在国内市场，Linux桌面操作系统的发展趋势非常迅猛。国内如中标麒麟Linux、红旗Linux、深度Linux等系统软件厂商都推出的Linux桌面操作系统，目前已经在政府、企业、OEM等领域得到了广泛应用。另外SUSE、Ubuntu也相继推出了基于Linux的桌面系统，特别是Ubuntu Linux，已经积累了大量社区用户。但是，从系统的整体功能、性能来看，Linux桌面系统与Windows系列相比还有一定的差距，主要表现在系统易用性、系统管理、软硬件兼容性、软件的丰富程度等方面。
>
> + Linux在移动嵌入式领域的发展
>
>   Linux的低成本、强大的定制功能以及良好的移植性能，使得Linux在嵌入式系统方面也得到广泛应用，目
>
>   前Linux以广泛应用于手机、平板电脑、路由器、电视和电子游戏机等领域。在移动设备上广泛使用的
>
>   Android操作系统就是创建在Linux内核之上的。目前，Android已经成为全球最流行的智能手机操作系
>
>   统，据2015年权威部门最新统计，Android操作系统的全球市场份额已达84.6%。此外，思科在网络防火墙和路由器也使用了定制的Linux，阿里云也开发了一套基于Linux的操作系统“YunOS”，可用于智能手机、平板电脑和网络电视；常见的数字视频录像机、舞台灯光控制系统等都在逐渐采用定制版本的Linux来实现，而这一切均归功与Linux与开源的力量。
>
> + Linux在云计算&大数据领域的发展
>
>   互联网产业的迅猛发展，促使云计算、大数据产业的形成并快速发展，云计算、大数据作为一个基于开源
>
>   软件的平台，Linux占据了核心优势；据Linux基金会的研究，86%的企业已经使用Linux操作系统进行云
>
>   计算、大数据平台的构建，目前，Linux已开始取代Unix成为最受青睐的云计算、大数据平台操作系统。

# 发行版本

> + Debian
>
>   Debian运行起来极其稳定，这使得它非常适合用于服务器。 debian这款操作系统无疑并不适合新手用户，而是适合系统管理员和高级用户。
>
> + Ubuntu
>
>   Ubuntu是Debian的一款衍生版，也是当今最受欢迎的免费操作系统。Ubuntu侧重于它在这个市场的应
>
>   用，在服务器、云计算、甚至一些运行Ubuntu Linux的移动设备上很常见。Ubuntu是新手用户肯定爱不
>
>   释手的一款操作系统。
>
> + 红帽企业级Linux 这是第一款面向商业市场的Linux发行版。它有服务器版本，支持众多处理器架构，包
>
>   括x86和x86_64。红帽公司通过课程红帽认证系统管理员/红帽认证工程师（RHCSA/RHCE），对系统管
>
>   理员进行培训和认证。
>
> + CentOS
>
>   CentOS是一款企业级Linux发行版，它使用红帽企业级Linux中的免费源代码重新构建而成。这款重构版
>
>   完全去掉了注册商标以及Binary程序包方面一个非常细微的变化。有些人不想支付一大笔钱，又能领略红
>
>   帽企业级Linux；对他们来说，CentOS值得一试。此外，CentOS的外观和行为似乎与母发行版红帽企业
>
>   级Linux如出一辙。 CentOS使用YUM来管理软件包。
>
> + Fedora
>
>   小巧的Fedora适合那些人：想尝试最先进的技术，等不及程序的稳定版出来。其实，Fedora就是红帽公
>
>   司的一个测试平台；产品在成为企业级发行版之前，在该平台上进行开发和测试。Fedora是一款非常好
>
>   的发行版，有庞大的用户论坛，软件库中还有为数不少的软件包。
>
> + Kali Linux
>
>   Kali Linux是Debian的一款衍生版。Kali旨在用于渗透测试。Kali的前身是Backtrack。用于Debian的所有
>
>   Binary软件包都可以安装到Kali Linux上，而Kali的魅力或威力就来自于此。此外，支持Debian的用户论
>
>   坛为Kali加分不少。Kali随带许多的渗透测试工具，无论是Wififi、数据库还是其他任何工具，都设计成立马
>
>   可以使用。Kali使用APT来管理软件包。
>
>   毫无疑问，Kali Linux是一款渗透测试工具，或者是文明黑客（我不想谈论恶意黑客）青睐的操作系统。
>
> +  ......

![image-20211207133110656](https://cdn.jsdelivr.net/gh/ls02/Image/img/202211022144557.png)

# OS概念

OS本质上是一个管理硬件资源分配的一个软件，而在OS上写的程序都是用户级程序。

![image-20211207133725923](https://cdn.jsdelivr.net/gh/ls02/Image/img/202211031437378.png)

---



# LInux目录结构

Linux的目录结构一般是由一棵多叉树组成，而这个多叉树只有一个根，这个根节点一般是`/`，像windows可以有多棵多叉树来组成目录文件结构.

**Linux一般的基础文件形状如下：**

![image-20211207140517727](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211207140517727.png)

## 为什么是树？

我们可以看到市面大部分的操作系统，它们的文件管理结构都是用的树状。

这是为什么呢？其实答案很简单因为树状有个特性，所有路径具有唯一性。

### 绝对路径&相对路径

**绝对路径：**因为具有唯一性所以，绝对路径指的是从根节点开始走走到目标节点，而目标节点存在的话，那么根据这条路径查找就一定能找到且没有其它方法能找到，这就是绝对路径。

**相对路径：**相对路径和绝对路径的区别是节点存在，相对路径不一定能找到，而绝对路径是一定能找到。因为相对路径是从某个节点开始往下找，而目标节点不一定在某个节点的下面所以有可能找不到。而绝对路径是从根开始找，只要目标节点存在那么就一定能找到。



# 一切皆文件

在LInux下面所有的任何设备或者文件、程序...都是文件，那么键盘和显示器是文件吗？答案：是的，在LInux下都是文件。

那么既然是文件，在C语言里面每次访问文件都需要打开文件，那么在Linux下面访问键盘和显示器都有打开文件吗？

答：都有打开不过是系统帮我们打开了。

我们在C语言里面都知道系统会帮我们默认打开三个文件分别是标注输入（stdin）、标注输出（stdout）和标准错误（stderr）。

![image-20211208145956633](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211208145956633.png)

# 导管

**用法：** 数据 | 文件名

**功能：** 用于传输数据到另一个地方，例如把键盘的数据传输到文件里面，或者文件里面的数据传输到显示器里面。

>  在计算机当中最重要的东西就是数据而导管是负责引道数据到达指定的地方，就像现实生活中的水管。



# 重定向&追加重定向

## 重定向

**用法：** echo "hello" > xx.txt

**功能：** 用于把某些内容输入到一个文本当中，其次输入进去前会清空目标文本





## 追加重定向

**用法：** echo “hello" >> xx.txt

**功能：** 把某些内容输入到一个文本当中，其次不会清楚文本原有内容而是在原有内容后面追加新的内容。



#shell命令以及原理的理解

Linux严格意义上来讲操作系统我们称之为核心（kernel），我们一般用户不能直接使用`kernel`都是通过一个外壳程序来完成我们想要的操作，你可能会问为什么直接用`kernel`来完成我们的交互而需要一个外壳程序来搞？这样效率不会降低吗？

准确的来讲是不会的，不仅不会反而还有所提高，因为我们想要直接跟`kernel`交互要学习很多底层才能做到和`kernel`交互这无疑是增加了我们的学习成本而且你就算懂这些知识，但如果操作不当将是很危险的行为，所以使用外壳程序不仅学习成本低还能过滤掉我们要执行比较危险的指令和无用指令。

> + 什么是shell程序？
>
>   shell程序翻译成人话就是外壳程序，而外壳程序的名字有很多，而为了方便称我们统一叫为shell程序。
>
> + shell程序
>
>   使用shell程序不仅是学习成本变低，同时更加安全，这不仅起到保护操作系统的作用，还起到了保护其它程序的安全。
>
> + shell作用&原理
>
>   外壳程序相当于翻译官，它会把你的指令翻译成相对的机器指令给“核心”同时它还会对你的指令进行过滤，如果是不合理的指令或者无意义的指令它会直接过滤掉并返回一个结果给你，如果是合理的指令它会给“核心”这时“核心”会给你一种结果，这种结果无非是同意执行和拒绝执行的结果。
>
>   shell程序在执行你的指令的时候会生成一个子进程来执行翻译给“核心”的操作，这种行为可以有效的保护shell程序的自身安全，就算执行的指令是合理的危险指令影响的也仅仅是它的子进程而不是它本身。
>
>   就好比腾讯把什么锅都甩给外包一样，出了问题跟腾讯没啥关系，有关系的是那些外包公司。

![image-20211209113404339](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211209113404339.png)

为了证明以上运行是正确的，为此我进行了测试，**如下图：**

首先我们先跑起一个死循环程序，为了方便我们观察shell脚本的运行。

![image-20211209153853793](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211209153853793.png)

```c
[ls@VM-4-7-centos ~]$ ps axj | head -1 && ps ajx | grep myprocclear
```

接着打开进程，我们可以看到我们运行的程序名叫myproc。

![image-20211209154141382](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211209154141382.png)

![image-20211209154503896](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211209154503896.png)

我们之前说shell脚本会生成一个子程序去执行我们给的指令，如果我们分析的没问题的话，那么当前进程的父进程应该就是shell脚本。

![image-20211209155034936](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211209155034936.png)

你可能会问，不是说是shell脚本生成的子进程吗？怎么它叫`~bash`不叫shell呢？因为shell脚本是所有外壳程序的统称。那如果我们杀死shell脚本的子进程我们跑的程序会不会停止呢？

![image-20211209155454677](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211209155454677.png)

我们可以看到程序终止了，所以说我们之前说的东西都是正确的。



---



# Linux权限

## Linux权限的概念

> Linux下分别有两种用户：
>
> 1. 超级用户（root用户）
> 2. 普通用户
>
> 它两的区别在于权限的区别，在Linux下面root用户的权限非常大基本所有操作它都能进行，包括删除系统这个指令（ps：所以网上才会调侃，《从删库到跑路》，权限越大，责任也越大所以有时候用root的进行操作的时候要清楚知道自己在干嘛）都能执行。
>
> 普通用户只能操作自己的工作目录下的文件进行读写操作，而不能到其它用户的目录下进行读和写操作包括创建，而root用户想对其它用户修改都可以做到，包括修改其它用户的密码。

## LInux切换用户

### su指令

**语法：** su [用户名]

**功能：** 用于切换用户（ps：如果是root用户切换其它用户则不需要密码验证即可挨饿换。）

## 权限管理

### 文件访问者分类（人）

> 1. 文件和文件目所有者：u---User
> 2. 文件和文件目录所有者所在的组的用户：g----Group
> 3. 其它用户：o---Others

### 文件类型和访问权限

#### 文件类型

> + d
>
>   文件夹（目录）
>
> + -
>
>   普通文件
>
> + l
>
>   软连接（类似windows的程序快捷键）
>
> + b
>
>   设备文件（硬盘、光驱等等）
>
> + p
>
>   管道文件
>
> + c
>
>   字符设备文件（例如：屏幕等串口设备）
>
> + s
>
>   嵌接口文件

#### 基本权限

i.读（r/4）：Read对文件而言，具有读取文件内容的权限；对目录来说，具有浏览该目录信息的权限

ii.写（w/2）：Write对文件而言，具有修改文件内容的权限；对目录来说具有删除移动目录内文件的权限

iii.执行（x/1）：execute对文件而言，具有执行文件的权限；对目录来说，具有进入目录的权限

iv.“—”表示不具有该项权限

### 文件权限值的表示方法

1. 字符表示法

   | LInux表示 | 说明           | LInux表示 | 说明         |
   | --------- | -------------- | --------- | ------------ |
   | r--       | 只读           | -w-       | 只写         |
   | --x       | 只可执行       | rw-       | 可读可写     |
   | -wx       | 可写可执行     | r-x       | 可读和可执行 |
   | rwx       | 可读可写可执行 | ---       | 无任何权限   |

2. 八进制数值表示法

   | 权限符号（读、写、执行） | 八进制 | 二进制 |
   | ------------------------ | ------ | ------ |
   | r                        | 4      | 100    |
   | w                        | 2      | 010    |
   | x                        | 1      | 001    |
   | rw                       | 6      | 110    |
   | rx                       | 5      | 101    |
   | wx                       | 3      | 011    |
   | rwx                      | 7      | 111    |
   | ---                      | 0      | 000    |

![image-20211209150343274](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211209150343274.png)

### 文件的默认权限

> Linux里创建普通文件或目录文件是有默认权限的，普通文件的默认起始权限是666，而目录文件的默认起始权限是777.
>
> 而我们可以通过`umask`来查看当前默认权限，这个默认权限的影响是创建文件的时候三个人（所有者、所属组、其它人）能有的权限，一般没动过默认权限的话，那么它给的是002。

![image-20211210130644846](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211210130644846.png)

那么这个002是什么意思的呢？你不是说它默认权限是666和777吗？

注意我说的是其实权限，它们确实是666和777而当前的002的意思是**如下图：**

![image-20211210131910204](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211210131910204.png)

==注意：以上是八进制的形式操作==

而这样做之后变成664又是啥意思，其实很简单我们十进制的话就是一个数字对应一个人，**如下图：**

![image-20211210132536358](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211210132536358.png)

你可以这么理解你想要创建的文件默认权限是多少的话可以减去相应的10进制如：我不想所属组能写，我就直接022

![image-20211210132934760](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211210132934760.png)

可以看到这样操作就能达到我们想要的目的。

### 文件目录权限和普通文件权限的区别

#### 普通文件权限

如果一个普通文件你所扮演的角色没有相应的权限会无法操作，如没有r权限那么你将无法打开普通文件，如果没有w你将没有写操作，如果强制写还是能写进去的。

如果想修改可以使用`chmod`指令进行文件权限修改，而如果这个文件所有者不是你，你无权修改当然你使用权限提升是可以修改的。

#### 目录文件权限

**面试题：** 目录文件的rwx权限对应的是什么效果？

**答：** r代表读，如果没有这个权限我们我们无法打印目录内的内容，因为要打印的话需要先读再输出到屏幕上，w代表写：我们依然能进入目录，但是不能创建任何文件，x代表可执行：如果没有可执行不能进入目录，不仅不能进入目录你就算有读和写的权限也不能查看目录内的详细内容，只能查看大概的文件名，而且也写不进去，所以目录文件不管怎么样都必须有可执行权限，如果没有那么什么都干不了。





# 粘滞位

> 粘滞位是一把锁，为什么会有粘滞位？
>
> 因为Linux下所有的文件权限只针对读和写，如果这个文件我无任何权限，那么我可不可以删掉它呢？答案是可以的，不仅普通用户的文件能删而且root用户的文件也一样能删，那你可能会说我们把工作目录设为不可读和写那么它不是不就删不了了吗？是的，但是有些文件我们需要公开任何人都能访问，但是 如果有人想删掉的话怎么办？我们可以用粘滞位，这个目录文件一旦有了粘滞位，目录文件及目录文件内的内容除了root用户和文件所有者能删除其它人无法删除。
>
> 添加粘滞位的方法：chmod o+t 文件目录名
>
> 如果你的目录是不可执行的话那么t会变成T，正常情况下没有都是t不会是T的因为目录文件无法访问也就不存在删除里面内容的问题了。

```shell
drwxrwxr-x 3 ls   ls   4096 Dec  8 09:25 code
drwxrwxr-t 3 ls   ls   4096 Dec 10 14:04 dir1
drwxr-xr-x 2 root root 4096 Dec 10 14:40 dir2
-r-xrw-r-- 1 ls   ls     69 Dec 10 13:41 test1.txt
-rw----r-- 1 ls   ls      0 Dec 10 13:29 test2.txt
-rwxrwxrwx 1 root root    0 Dec 10 13:44 test3.txt
[root@VM-4-7-centos ls]\# chmod o+t dir2 #添加粘滞位
[root@VM-4-7-centos ls]\# ll
total 16
drwxrwxr-x 3 ls   ls   4096 Dec  8 09:25 code
drwxrwxr-t 3 ls   ls   4096 Dec 10 14:04 dir1
drwxr-xr-t 2 root root 4096 Dec 10 14:40 dir2
-r-xrw-r-- 1 ls   ls     69 Dec 10 13:41 test1.txt
-rw----r-- 1 ls   ls      0 Dec 10 13:29 test2.txt
-rwxrwxrwx 1 root root    0 Dec 10 13:44 test3.txt

其它用户无法删除
drwxrwxr-x 3 ls   ls   4096 Dec  8 09:25 code
drwxrwxr-t 3 ls   ls   4096 Dec 10 14:04 dir1
drwxr-xr-t 3 root root 4096 Dec 10 14:42 dir2
-r-xrw-r-- 1 ls   ls     69 Dec 10 13:41 test1.txt
-rw----r-- 1 ls   ls      0 Dec 10 13:29 test2.txt
-rwxrwxrwx 1 root root    0 Dec 10 13:44 test3.txt
[ls@VM-4-7-centos ~]$ rm -r dir2
rm: descend into write-protected directory ‘dir2’? y
rm: remove write-protected regular empty file ‘dir2/test.txt’? l^H^C
[ls@VM-4-7-centos ~]$ rm -r dir2
rm: descend into write-protected directory ‘dir2’? ^C
[ls@VM-4-7-centos ~]$ rm -rf dir2
rm: cannot remove ‘dir2/test.txt’: Permission denied
rm: cannot remove ‘dir2/dir3’: Permission denied
```



---



# Linux常用工具

## 软件包管理器yum

### 什么是软件包

> 在Linux下安装软件最直接的方法是源代码安装，但是这样的话有点麻烦，特别是对系统有依赖文件的时候还需要自行配置。
>
> 而有些人比较勤快它们提前把源代码编译，并且帮你把配置文件给配置好，并且打包好而这种包通常叫`rpm`安装包，而这个包还是一点缺陷的比如这款软件依赖的系统文件发生了变化，那么这个软件也就相应的运行不了，如果想要能运行要么自行配置解决，要么就卸载重新下载新版本的软件包。
>
> 而`yum`软件包管理器相当于手机上的”某某应用商店“我们下载直接到`yum`上下载即可，一般能下载是因为有人把软件都放到一个服务器上面而这个服务器我们通常叫为包服务器，在`yum`的包服务器软件通常是安全的（ps：可以理解成为官方发布的软件，标准包管理器）而有些软件并没有放在包管理器上而是放在扩展源包管理器上（ps：可以理解为非官方的软件，非标准包管理）这些软件并不是因为不安全才没放进标准的包管理器上可能是因为种种原因，但是这并不是我们关心的重点，我们的重点是能不能下载我们的目标软件。
>
> 如果在标准包服务器上下载不到，我们需要去非标准的包服务器上下载，而想要去非标准包服务器上下载我们需要安装一个扩展源。
>
> ```shell
> sudo yum install -y epel-release #安装扩展源
> ```
>
> ![image-20211211105709907](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211211105709907.png)

### yum下载&卸载

#### 卸载指令

如果你有个软件想卸载那么你可以输入以下指令

```shell
sudo yum remove 软件名
```

#### 下载指令

如果你想下载某款软件，你可以先查找它是否存在，也可以直接下载。

```shell
sudo yum list | grep 软件名 #用于查找某款软件是否在包服务器上面
sudo yum install 软件名 #用于下载软件
sudo yum list #用于查看包服务器内有些什么软件，不过由于数量过多建议把内容打印到文本内查看。
```



## vim文本编辑工具

`vim`是一款强大的文本编辑器，它可以编写代码并且使关键字代码拥有高亮且代码补齐……等等功能（ps：这些功能需要自行配置，默认啥都没有的），所以在写代码方面这款软件简直是神器。

当然它只仅仅是文本编辑器并不具备编译代码和调试……等等功能，这不像windows上的编译器，widows下面的vs、vc和dev……等等是集成编译器（文本、调试、编译、链接、生成可执行一体化的编译器称为集成编译器）在Linux下面进行写代码的时候需要用到多款软件来完成，当然LInux下面也有集成的编译器，但是个人认为用非集成的编译器比较好。

**vim键盘图：**

![image-20211211111622318](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211211111622318.png)

### vim的多种模式

#### vim命令行模式

这个模式下是不能编辑文本的，一般这种模式下我们使用于退出或拷贝……等等的一些操作，如果想要编辑文本需要进入插入模式。

**常用指令：**

> + i
>
>   切换为插入模式
>
> + ：
>
>   切换为底行模式

这三中模式之间的切换都必须要在命令模式下才能互相切换，具体**如下图：**

![image-20211211113409182](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211211113409182.png)

##### 拷贝操作

| 拷贝指令 |                             说明                             |
| :------: | :----------------------------------------------------------: |
|   nyy    | n为数字，拷贝光标所在到下n行，列如：3 yy//就是拷贝当前行和下三行，共计四行。 |
|   y1G    |                    拷贝光标所在行到第一行                    |
|    yG    | 拷贝当前行到末尾，如果遇到}那么它只会拷贝到}后的一行之后的都不会拷贝。 |
|    y0    | 拷贝光标前面的所有字符,且光标会移动到行首（注意：是当前行且不拷贝光标本身那个字符） |
|    y$    | 拷贝光标当前到行尾的字符（注意：是拷贝当前行，且包括拷贝光标的字符） |
|    yy    |                        拷贝光标当前行                        |

#### 粘贴操作

|  粘贴指令  |                             说明                             |
| :--------: | :----------------------------------------------------------: |
|     p      | 粘贴拷贝的内容，在光标行的下一行进行粘贴操作，如果下一行有数据那么会被推到后面，如果是和拷贝数据一样的数据是不会拷贝出来。 |
|     P      | 粘贴拷贝内容，在光标当前行粘贴并把原光标位置的数据往下推，如果相同不会拷贝出来。 |
| n + p（P） |    粘贴多分拷贝内容，n代表份数，如：33 p（P）粘贴33份内容    |

#### 删除操作

| 删除操作 |                      说明                      |
| :------: | :--------------------------------------------: |
|    dd    |                 删除光标所在行                 |
|   ndd    |     n为数字，删除多行，例如：2 dd 删除两行     |
|   d1G    |    删除光标以上的所有数据（包括光标当前行）    |
|    dG    |    删除光标以下的所有数据（包括光标当前行）    |
|    d$    | 当前行删除光标后面的所有字符（包括光标的字符） |
|    d0    | 当前行删除光标前面所有的字符（不包括光标本身） |
|    x     |          在一行中，删除光标位置的字符          |
|    X     |            删除光标位置的前一个字符            |
| nx（X）  |             n为数字，删除多个字符              |



#### 撤销操作

| 撤销指令 |   说明   |
| :------: | :------: |
|    u     |   撤销   |
| [Ctrl]+r | 取消撤销 |

#### 光标移动操作

|    光标移动指令    |                             说明                             |
| :----------------: | :----------------------------------------------------------: |
| h 或 向左箭头键(←) |                     光标向左移动一个字符                     |
| j 或 向下箭头键(↓) |                     光标向下移动一个字符                     |
| k 或 向上箭头键(↑) |                     光标向上移动一个字符                     |
| l 或 向右箭头键(→) |                     光标向右移动一个字符                     |
|    [Ctrl] + [f]    |     屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)      |
|    [Ctrl] + [b]    |      屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)      |
|    [Ctrl] + [d]    |                     屏幕『向下』移动半页                     |
|    [Ctrl] + [u]    |                     屏幕『向上』移动半页                     |
|         +          |                  光标移动到非空格符的下一行                  |
|         -          |                  光标移动到非空格符的上一行                  |
|      n<space>      | 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。 |
|  0 或功能键[Home]  |      这是数字『 0 』：移动到这一行的最前面字符处 (常用)      |
|  $ 或功能键[End]   |               移动到这一行的最后面字符处(常用)               |
|         ^          |                移动到这行最前面的非空字符位置                |
|         H          |         光标移动到这个屏幕的最上方那一行的第一个字符         |
|         M          |          光标移动到这个屏幕的中央那一行的第一个字符          |
|         L          |         光标移动到这个屏幕的最下方那一行的第一个字符         |
|         G          |                移动到这个档案的最后一行(常用)                |
|         nG         | n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) |
|         gg         |        移动到这个档案的第一行，相当于 1G 啊！ (常用)         |
|      n<Enter>      |              n 为数字，光标向下移动 n 行(常用)               |
|         w          |                    光标位置，跳过一个单词                    |
|         b          |                   光标位置，回到上一个单词                   |
|         e          | 光标位置，跳过一个单词，但光标会在跳过的单词的最后一个字符上 |

#### 查找

|                       /word                        | 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) |
| :------------------------------------------------: | :----------------------------------------------------------: |
|                       ?word                        |        向光标之上寻找一个字符串名称为 word 的字符串。        |
|                         n                          | 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ |
|                         N                          | 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 |
|               :n1,n2s/word1/word2/g                | n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：<br/>『:100,200s/vbird/VBIRD/g』。(常用) |
|  **:1,$s/word1/word2/g** 或 **:%s/word1/word2/g**  | 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) |
| **:1,$s/word1/word2/gc** 或 **:%s/word1/word2/gc** | 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) |

#### 重复上一个指令

| 重复指令 |                             说明                             |
| :------: | :----------------------------------------------------------: |
|    .     | 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用) |

### vim插入模式

| 插入模式指令 |                             说明                             |
| :----------: | :----------------------------------------------------------: |
|      i       |                   在光标位置，进入插入模式                   |
|      I       |              在光标位置非空位置，进入插入模式。              |
|      a       |           光标位置向后移动一个字符，再进入插入模式           |
|      A       |   光标行的最后一个字符位置向后移动一个字符，再进入插入模式   |
|      o       | 在光标行的下一行增加一个空行，光标并移动至新增行，再进入插入模式 |
|      O       | 在光标的上一行，增加一个空行，光标并移动至新增行，再进入插入模式。 |
|      cw      |            删除光标位置的一个单词，并进入插入模式            |
|     cnw      |             n为数字，删除n个单词，并进入插入模式             |

### vim替换模式

| 替换模式指令 |                             说明                             |
| :----------: | :----------------------------------------------------------: |
|      r       |       进入替换模式，替换光标位置的字符（只能替换一次）       |
|      R       | 进入替换模式，替换光标位置的字符，光标并向后移动一个字符，直到收到esc指令才结束。 |

### vim底行模式

|        底行模式指令         |                             说明                             |
| :-------------------------: | :----------------------------------------------------------: |
|              q              |                           退出文本                           |
|             q！             |                           强制退出                           |
|              w              |                           保存文本                           |
|             wq              |                          保存并退出                          |
|             w！             |                           强制保存                           |
|            wq！             |                        强制保存并退出                        |
|             ZZ              |              跟wq效果类似（ZZ不用进入底行模式）              |
|             ZQ              |       不保存并强制退出和q！类似（ZQ不用进入底行模式）        |
|              w              | 将文本的内容拷贝到一个新创建的文本内，如果是已创建的文本不能这么操作，只能是未创建的文本。 |
|          r 文件名           |     把另一个文档的内容拷贝到当前文本光标所在位置的下一行     |
|       n1,n2 w 文件名        | 将本文本第n1行到n2行的内容拷贝到另一个新创建的文档，如果新的文档易已存在，则无法执行。 |
|           ! 指令            |    不退出文本，在文本内执行Linux指令。例如：! ls 这类操作    |
| s/替换目标字符/替换后的字符 | 用于替换文本内所有相关的字符替换为新的字符。例如：s/aaa/bbb/把aaa替换成bbb |
|             vs              |                 分屏，同时进行多个文件的操作                 |

### vim环境变量的更改

| 环境变量指令 |                        说明                        |
| :----------: | :------------------------------------------------: |
|   :set nu    | 显示行号，设定之后，会在每一行的前缀显示该行的行号 |
|  :set nonu   |            与 set nu 相反，为取消行号！            |



### 块选择模式

#### 批量注释

> **Ctrl + v** 进入块选择模式，然后移动光标选中你要注释的行，再按大写的 **I** 进入行首插入模式输入注释符号如 **//** 或 **#**，输入完毕之后，按两下 **ESC**，**Vim** 会自动将你选中的所有行首都加上注释，保存退出完成注释。
>
> 取消注释：**Ctrl + v** 进入块选择模式，选中你要删除的行首的注释符号，注意 **//** 要选中两个，选好之后按 **d** 即可删除注释，**ESC** 保存退出。

##### 底行命令注释

> 使用下面命令在指定的行首添加注释。
>
> 使用名命令格式： **:起始行号,结束行号s/^/注释符/g**（注意冒号）。
>
> 取消注释：
>
> 使用名命令格式： **:起始行号,结束行号s/^注释符//g**（注意冒号）。

**例子：**

1. 在 10 - 20 行添加 **//** 注释

   ```
   :10,20s#^#//#g
   ```

2. 在 10 - 20 行删除 **//** 注释

   ```
   :10,20s#^//##g
   ```

3. 在 10 - 20 行添加 **#** 注释

   ```
   :10,20s/^/#/g
   ```

4. 在 **10 - 20** 行删除 # 注释

   ```
   :10,20s/#//g
   ```



## gcc/g++编译器的使用

### gcc如何使用

**语法：** gcc [选项] 编译文件

**功能：** 用于编译C语言程序，编译C++程序使用g++。

**选项：**

|   指令   |                             说明                             |
| :------: | :----------------------------------------------------------: |
|    -E    | 只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里面 |
|    -S    |                编译到汇编语言不进行汇编和链接                |
|    -c    |                        编译到目标代码                        |
|    -o    |                        文件输出到文件                        |
| -static  |                此选项对生成的文件采用静态链接                |
|    -g    |             生成调试信息。GNU 调试器可利用该信息             |
| -shared  | 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库 |
| -O0(0-3) | 编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高 |
|    -w    |                     不生成任何警告信息。                     |
|  -whall  |                      生成所有警告信息。                      |

**注意：**==gcc编译器编译不是直接生成可执行程序的，什么参数都不给的情况下它默认执行：预处理->编译->汇编->链接==

### 预处理

> 预处理是程序执行的第一步，这一步主要是用于删除注释、头文件展开、宏替换和条件编译这几项操作，我们可以使用gcc的`-E`选项来进行查看它对源代码进行了那些处理。

![image-20211211220659067](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211211220659067.png)

我们可以从图中观察到，这个阶段gcc确实进行了以上处理。

### 编译

编译这个阶段主要做的工作就是将C代码编译成汇编代码。

![image-20211211221255049](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211211221255049.png)

### 汇编

这个阶段主要是生成目标文件，也就是windows下的obj文件而obj文件是二进制的因为已经成为机器码了，所以我们显示器上是无法显示出来的，通常能显示出来的都是乱码。

![image-20211211221914040](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211211221914040.png)

### 链接

这个阶段主要是用于链接，虽然代码已经生成为机器码了，cpu能看懂但是它找不到里面的函数调用的地址，所以我们只需进行链接obj文件即可找到对应的函数地址，这个时候代码才是可执行程序。

由于链接不要参数直接输入

```
gcc obj文件
```

这个时候会得到a.out的可执行程序，如果有重命名的话那么就不是a.out。

```shell
[ls@VM-4-7-centos 11]$ ll
total 44
-rwxrwxr-x 1 ls ls  8400 Dec 11 22:23 a.out
-rw-rw-r-- 1 ls ls   401 Dec 11 22:08 test.c
-rw-rw-r-- 1 ls ls 16921 Dec 11 22:13 test.i
-rw-rw-r-- 1 ls ls  1569 Dec 11 22:19 test.o
-rw-rw-r-- 1 ls ls   507 Dec 11 22:19 test.s
[ls@VM-4-7-centos 11]$ ./a.out
heello centos
hello world
[ls@VM-4-7-centos 11]$ 

```

**注意：** ==gcc默认生成调用的是动态链接，如果需要静态链接需要带上`gcc -static`编程静态链接==

## 库

什么是库？你可能会说我没听过库啊？而且也没使用过！

其实你一直都在使用库像C语言的头文件或者C++的头文件等等……你日常的写练习代码都是用过的，只是你没察觉到而那个阶段也不会有人跟你讲库的概念，所以你就会认为我从来没使用过库，而库又分为两种。

1. 静态库
2. 动态库

### 静态库

静态库顾名思义就是静态的，那么怎么个静态法呢？

像刚才上面的预处理阶段，我们就看到头文件展开了而且展开了很多直接让我们的代码从几十行增加到八百多行，而这是为什么呢？这其实就是静态库，静态库就是使用自己代码下面的函数时候不会去调外面的，而这样做的代价就是内存和磁盘占用就很大因为它是直接从动态库内拷贝过来的代码，但是它有一个优点不依赖第三方库任何平台都能跑移植性高。

**总结：**

> + 优点
>   1. 移植性高
>   2. 不依赖第三方库
> + 缺点
>   1. 体积大
>   2. 加载慢
>   3. 存在空间浪费

### 动态库

动态库本质就是使用官方库里的函数，但是不会对其进行拷贝到本地，具体过程是：代码使用库函数->调用库->库返回调用结果。

这样做的优点就是不用会产生重复拷贝，使得代码占用体积小，内存加载更快，但是依赖第三方库平台不同库里面的内容也会不些小变动这使得移植性较差。

**总结：**

> + 优点
>   1. 内存加载快
>   2. 体积小
>   3. 不存在空间浪费
> + 缺点
>   1. 依赖第三方库
>   2. 可移植性较差

## gdb调试工具

**注意：**  ==gcc编译出来的默认是`release`版本，这个版本是没有 调试信息的，我们需要手动调整成`debug`版本才有调试信息，需要在编译时加上`-g`选项才是`debug`版本。==

> + list／l 行号：显示binFile源代码，接着上次的位置往下列，每次列10行。
> + list／l 函数名：列出某个函数的源代码
> + r或run：运行程序
> + n 或 next：单条执行
> + s或step：进入函数调用
> + break(b) 行号：在某一行设置断点
> + break 函数名：在某个函数开头设置断点
> + info break ：查看断点信息。
> + fifinish：执行到当前函数返回，然后挺下来等待命令
> + print(p)：打印表达式的值，通过表达式可以修改变量的值或者调用函数
> + p 变量：打印变量值。
> + set var：修改变量的值
> + continue(或c)：从当前位置开始连续而非单步执行程序
> + run(或r)：从开始连续而非单步执行程序
> + delete breakpoints：删除所有断点
> + delete breakpoints n：删除序号为n的断点
> + disable breakpoints：禁用断点
> + enable breakpoints：启用断点
> + info(或i) breakpoints：参看当前设置了哪些断点
> + display 变量名：跟踪查看一个变量，每次停下来都显示它的值
> + undisplay：取消对先前设置的那些变量的跟踪
> + until X行号：跳至X行
> + breaktrace(或bt)：查看各级函数调用及参数
> + info（i) locals：查看当前栈帧局部变量的值
> + quit：退出gdb



## makefile自动化编译工具

> makefile自动化工具能使我们减少编译时要敲的代码，同时会不会用makefile也是考察你是否具有大型项目编程的能力，因为在LInux下大型项目有上百个obj文件，如果手打的话你可以想象一下效率有多低，其次如果除了bug调试的时候这样又打一遍岂不是折磨？
>
> 所以我们有必要掌握makefile这款自动化编译工具，有了它我们开发效率会比没有使用它更快，特别是当做大项目的时候有明显的差距。

#### make指令

**语法：** make

**功能：** 用于执行`makefile`的内容，使用make前必须有个`makefile`不然无法使用。

#### makefile的语法

使用makefile必须明白依赖关系和依赖方法，什么是依赖关系呢？依赖关系就好比你使用某个库的函数你必须包含这个库的头文件，这就是依赖关系那么依赖方法呢？

依赖方法也很简单可以理解成调用库函数的具体操作，在Linux下以上操作都是类似的。

具体操作我们先创建一个makefile文件，接着在里面写上**如下指令：**

![image-20211212181613038](https://cdn.jsdelivr.net/gh/ls02/Image/img/image-20211212181613038.png?raw=true)

![image-20211212182015826](https://github.com/ls02/Image/blob/main/img/image-20211212181613038.png?raw=true)



这些已经可以完成绝大多数场景的使用了，暂时先讲到这，后续的文章会补充这个工具的其它操作。

### 生成多个可执行文件

![image-20220928173613916.png](https://github.com/ls02/Image/blob/main/img/image-20220928173613916.png?raw=true)



# \r&\n

> 回车和换行是区别是什么？
>
> 你可能会说这两个不是同一个东西吗？能有啥区别不都是换行？
>
> 如果从细的讲这两个东西就不是同一个东西，因为换行是在当前行往下换，但是它的位置是不会动，也就是说在你上一行的字符下面，而不是跑到行开头。
>
> 而回车则是先换行然后再跑到行首，这就是区别那么我们说这个有啥意义呢？
>
> 当然有，我们先看一段程序。

```c
#include <stdio.h>    
#include <unistd.h>    
    
int main()    
{    
  printf("hello Linux");    
  sleep(1);    
                                                                                             
  return 0;                                                                               
}   
```

你们觉得是先输出再休眠还是先休眠再输出呢？

答案：其实是先休眠再输出，但是加了`\n`就是先输出再休眠了，你们可能会好奇这是为什么呢？这其实是一种缓冲造成的结果。

## 缓冲区

一般缓冲区有三种缓冲策略分别是：无缓冲、行缓冲和全缓冲，我们当前代码所造成的情况是行缓冲。            

1. 无缓冲                     

   立即刷星输出到显示器上的内容

2. 行缓冲

   缓冲区满了或遇到`\n`才立即刷新

3. 全缓冲

   缓冲区满了才刷新。

而`\n`和`\r`的区别在下面代码也就体现出来了，**如下：**

```c
#include <stdio.h>
#include <unistd.h>

int main()
{
    int i = 10;
    while(i){
        printf("%2d\r", i);
        fflush(stdout);//使缓冲区立即刷新到屏幕
        sleep(1);
        i--;
    }
}
```

我们用`\r`就会发现可以获得一个倒计时的程序，如果用换行我们就会发现不能实现倒计时。

---



# 冯·诺依曼体系

数学家[冯·诺依曼](https://baike.baidu.com/item/冯·诺依曼/388909)提出了计算机制造的三个基本原则，即采用二进制逻辑、程序存储执行以及计算机由五个部分组成（[运算器](https://baike.baidu.com/item/运算器/2667320)、[控制器](https://baike.baidu.com/item/控制器/2206126)、[存储器](https://baike.baidu.com/item/存储器/1583185)、[输入设备](https://baike.baidu.com/item/输入设备/10823368)、[输出设备](https://baike.baidu.com/item/输出设备/10823333)），这套理论被称为冯·诺依曼体系结构。

早些的时候设备交互都是输入和输出……等等设备都是直接跟cpu交互，而这些外设设备都有一个通病那就是慢，而cpu快这样的话它们之间运行效率是非常低的。

![image-20211213105254460](https://raw.githubusercontent.com/ls02/Image/main/img/202302021358370.png)

而后来冯诺依曼提出在原有基础上加个缓冲区而 这个缓冲区就是存储器（存储器的特点不快不慢，能存储数据）有了它cpu不用慢慢等输入设备的传输数据而是让输入设备提前把数据放到存储器内，而cpu不和其它设备交互只和存储器交互，也就是说cpu取数据和返回结果的数据都是在存储器内进行的，而其它设备需要处理的数据也是都放在存储器内，而cpu怎么知道它们有数据要处理呢？

这很简单cpu和其它设备有一个控制信号它们各个之间都互相连接的，因为控制信号很快所以会有这个而设备有数据需要处理会发射一个脉冲信号到控制信号内，cpu捕捉到这个信号就会到存储器内读取数据其它的设备也是同理，这就是我们熟知的冯诺依曼体系了。

为了方便理解我举个简单的例子：冯诺依曼体系就好比于去吃火锅，而早些的机器结构是去餐馆，而存储器（内存条）就相当于是火锅，而我们要做的是去前台拿菜，然后我们直接放在火锅里面煮，煮的期间我在去拿菜这样我就可以边吃边等菜熟了，而我的成本只要跑两次等菜熟了我们就吃吃完了，那么下一轮的菜也熟了，而存储器就是充当这样的角色，cpu只用去内存里面拿处理完再把结果放回去然后其它的设备拿，这样cpu和其它设备就不会存在你等我我等你的这样的状态了。

而去餐馆我们都知道先去前台点菜，点完菜就干等等他抄好了上菜，才开始吃而如果菜很多的话我们要等的时间也更久因为他是做完才上菜，而不像火锅可以边吃边下菜。

![image-20211213112317028](https://raw.githubusercontent.com/ls02/Image/main/img/202302021358312.png)

**总结：** 

> **站在内存的角度** cpu只和内存打交道，外设也只和内存打交道，这样大幅度提高了效率。
>
> **输入设备：** 键盘、网卡、话筒和摄像头……等等
>
> **输出设备：** 显示器、硬盘、音响和网卡……等等
>
> 数据要处理，必须先载入到内存中，局部性原理，操作系统完成。
>
> 寄存器不仅仅只有cpu有，其它设备也是有的。
>
> 各种硬件单元之间连接用的是：总线（IO总线，系统总线）

知道以上东西之后我们来理解下网络，我们每次用微信发信息的时候都是通过网卡发送的，先由cpu处理处理好后cpu会把要发送到网络上的数据打包我们简称数据包发送给网卡，而另一份直接发送给输出设备，所以有时候我们网络不好的时候会发现会有个小圈一直转，如果对方接收到了会消失如果超过一定时间还没接收到你刚刚发送的信息就会出现感叹号。

具体过程**如下图：**

![image-20211213133908395](https://raw.githubusercontent.com/ls02/Image/main/img/202302021358081.png)

**关于冯诺依曼体系结构，我必须强调几点：**

> 不考虑缓存的情况这里的CPU只能对内存进行读和写，不能访问外设（输入或输出设备）
>
> 外设（输入或输出设备）要输入或者输出的数据，也只能写入内存或者从内存中读取。

---



# 操作系统

## 概念

>任何计算机系统都包含一个基本的程序集合，称为操作系统(OS)。笼统的理解，操作系统包括：
>
>+ 内核（进程管理，内存管理，文件管理，驱动管理）
>+ 其他程序（例如函数库，shell程序等等）

## 设计OS的目的

> + 与硬件交互，管理所有的软硬件资源
> + 为用户程序（应用程序）提供一个良好的执行环境

## 定位

> 在整个计算机软硬件架构中，操作系统的定位是：**一款纯正的** 搞管理的软件

操作系统（OS）是一款软件，它的作用是用来管理软硬件和资源分配，主要管理的是文件系统、内存、硬件、驱动和进程……等等。

为什么会有驱动？因为系统要是自己管理设备的输入和输出的话成本很高，因为有很多家不同的厂商生产设备，这也导致了很多设备的接入方式不同，而如果操作系统管理这些设备的话只要这些厂商有大的变动的话那么操作系统的内核要重新编译，这样的成本实在是太高了所以有了驱动让驱动来管理操作系统只负责调用驱动即可，而这样的操作也导致了结藕，结藕的大概意思是操作系统和硬件层没有太大的关系，也就是说依赖性低也就是它们俩谁少了谁都不影响对方，同时操作系统还会暴露一些接口而这些接口都是系统库，这些库都是系统库函数用来更安全的调用系统。

如果不这么做的话用户调用操作系统的成本很高同时对操作系统的安全有威胁，所以暴露这些接口主要是满足用户的需求同时保护自身安全。

![image-20211213190546164](https://cdn.jsdelivr.net/gh/ls02/Image/img/202302021358688.png)

**总结：**

> **系统调用和库函数概念**
>
> + 在开发角度，操作系统对外会表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口，叫做系统调用
> + 系统调用在使用上，功能比较基础，对用户的要求相对也比较高，所以，有心的开发者可以对部分系统调用进行适度封装，从而形成库，有了库，就很利于更上层用户或者开发者进行二次开发。
>
> 简单来说在系统下对程序的管理很简单，首先需要从内存拿到对应的数据再用结构体描述出来，同时我们也知道程序是可以同时运行多个的所以操作系统为了管理这些程序需要cpu资源，而cpu的资源又是有限的而你线程又是很多个所以需要一个链表或其它高效的数据结构来管理。
>
> 上面这段总结总一句话是：先描述（用结构体存储各个对应的信息），再组织（用一个链表或者其它高效的数据结构管理这些结构体）。

![image-20211213200116505](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211213200116505.png)

## 进程

**概念：**

`windows`上面运行的各种软件和开发的程序运行起来我们叫把程序跑起来，而程序的本质就是进程，所以专业的叫法是进程跑起来而不是程序跑起来，打开`windows`下面的任务管理系统上看到的程序其实都是进程。

cpu对进程的处理有个规定：每个进程都有一个固定的运行时间周期，一旦过了这个周期那么这个进程就被结束不管你跑没跑完，如果没跑完会有个程序计数器会存储地址，这样下次再跑这个进程就不会重头跑而是在结束前的位置继续跑。

而为什么有这个规定呢？其实原因很简单就像你去医院看病，得到前台挂号排队因为医生有限所以需要排队，而cpu也同理你进程这么多我cpu就一个如果我我是先跑一个程序再结束的话，如果那个程序特别长要执行很久从你用户的角度上看电脑像是卡死了，所以在有限的资源上表现出你每个进程都在运行的话就必须每隔一段时间久换一个进程而这个时间非常的短，在我们人类的角度上看几乎察觉不到这机制，这也使的我们的机器像是能同时运行多个进程的错觉。

## 进程的区别程序

> **进程：**由数据和代码组成存放在内存上
>
> **程序：**单纯的代码存放在硬盘上
>
> **总结：** 程序不等于进程，进程是由程序加一些数据组成的，运行在内存中，而程序仅仅是代码存放在硬盘中

### 描述进程-PCB

> +  程序信息和数据被放在一个叫做进程控制块的数据结构中，可以理解为进程属性的集合
> + 我们称之为PCB，在Linux下的PCB是一个`task_struct`的结构体
> + `task_struct`是Linux内核的一种数据结构，它会被装载到RAM(内存)里并且包含着进程的信息

![image-20211213201646333](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211213201646333.png)

#### 如何理解PCB？

PCB就是一个进程控制块多个PCB会被操作系统用链表结构来管理，而PCB结构下都包含这些字段**如下：**

+ **标识符：**描述进程的唯一==标识符（pid）==，用来区分其它进程
+ **状态：**任务状态，退出码，退出信号等
+ **优先级：** 进程执行的优先级
+ **程序计数器：**程序中即将被执行的下一条指令的地址
+ **内存指针：**类似寄存器的内的指针主要是用来改变该程序在代表中的执行流
+ **上下文数据：** 内存加载进CPU时候，当时间片到了要把此时的数据保存，方便下次进入CPU的时候恢复现场
+  **I/O状态信息：**显示I/O请求，分配给进程的I/O设备和被进程使用的文件列表
+  **记账信息：**主要记录了处理器的时间总和，使用时钟数总和时间限制等

#### 前台进程

我们可以跑一个进程看看，在此我写了一个死循环

```c
int main()
{
	while (1);
    
    return 0;
}
```

![image-20211213203748662](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211213203748662.png)

我们可以看到当执行了这个进程之后无论，我们怎么输入指令系统都不会响应我们，因为前台进程只能运行一个而shell命令也是一个进程所以运行了死循环就运行不了shell脚本了。

如果我们想执行shell脚本就得让它变成后台进程所以我们在执行它的命令加上个`&`就好了。

![image-20211213205342223](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211213205342223.png)我们可以看到R+变成R了这代表什么意思？

> + \+
>
>   字母带+说明是前台运行
>
> + R
>
>   进程正在运行
>
> + S
>
>   进程在休眠



#### 优先级

为什么要有优先级？

因为cpu资源有限加上有很多进程，所以为了保证每个PCB都能执行到，cpu会进行优先级设置。

如何理解进程排队？

![image-20211213210536345](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211213210536345.png)

#### 程序计数器

cpu内有很多种寄存器，而`EIP`寄存器是专门来存储地址的，而这个存储器存的地址是cpu下一条要执行的指令的地址，因为cpu在运转的过程都是围绕着三个指令一直运转：取指令->分析指令->执行指令。

#### 时间片

每个进程的都有一个固定的执行周期而这个周期叫做时间片，每过一段时间就要换个进程执行。

#### 上下文数据

因为每过一个时间片就要换一个进程而它怎么知道之前的进程执行到哪一步了呢？

cpu在对进行清理的时候把执行到哪一步的位置有个指针存起来了，而这个指针是用的寄存器存起来的所以再清理这个进程的时候它会把它的临时数据也放到内存当中这样它下次再跑到这个进程的时候也能还原之前执行的位置了。

#### 进程状态

>  每个进程在运行时都会有一个状态每种状态都有不同的含义

#### 进程状态的意义

> 进程状态主要使用来方便操作系统判断，来完成特定功能，比如：调度，本质这就是一种分类

###### R状态

`R`状态代表的是该进程在运行或正准备运行，也就是说`R`状态进程不一定是在执行而有可能是在准备被执行，说人话就是虽然我没在运行但是我准备好了随时可以运行，因为不一定是要运行时才能是`R`状态只要是能运行就可以是`R`状态。

 因为`PCB`的结构里面的其它结构不一定是该结构的节点而有可能是其它结构不过它在`PCB`下面充当`PCB`的节点，说人话就是虽然`PCB`是一个链式结构或者其它更高效的结构但是，它的每个节点不一定是一样的节点有可能它的某个节点是红黑树，然后另一个节点是顺序表这样的结构，你可以把`PCB`理解成存储其它结构的链式结构。

而我们也说了，一个进程就有一个`PCB`那么这么多进程，它怎么高效的找到下一个`R`状态的进程执行呢？如果说是遍历的话这效率就是O(N)了，很显然`Linux`不会直接遍历来找因为这样效率太低了，所以它会为`R`状态的进程创建一个队列，这样按优先级排的进程就能先执行了同时效率还提升这样找就是O(1)而不是O(N)了。

![image-20211215130957716](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211215130957716.png)

##### S状态

S状态的进程是浅睡眠，浅睡眠它能被Kill掉也就是说别人还在睡觉我们就KIll了它，不仅能被kill掉还能随时被叫醒执行其它任务，它在LInux下的意思是待机或者挂起。



##### D状态

D状态和S状态类似不过D状态是深度睡眠，在深度睡眠状态不会被任何人kill掉包括操作系统，如果对它执行kill它只会在自动醒时候才会执行，因为在深度睡眠它不听到任何指令，所以任何人都不能对它下指令为什么会有D状态呢？

**举个例子：** 假设一个进程抱着一堆数据对着硬盘说你把这些写进去，硬盘得到指令就把它这堆数据拿去写了，而被拿去写的时候这个进程又不需要被执行或者其它操作那么它会进入S状态（浅睡眠），而这个时候操作系统的内存资源很紧张已经对操作系统的正常运行造成影响了而这时操作系统会对无用进程进行kill然后释放资源来缓解资源紧张问题，而这时它会对进程进行检查它发现有个进程是S状态，而这个时候操作系统会把它kill掉来缓解资源紧张（PS：可以理解成，公共厕所就2个，然后4个人在排队上厕所而你不用厕所却占着这个坑，所以公共厕所管理员会把你T出去让别人需要的来上）而这个时候硬盘写数据写失败了回来叫S进程问它接下来要如何处理，而这个时候S进程已经被kill掉了，所以硬盘如何喊都不会有任何响应。

这个时候硬盘就面临着很尴尬的问题那就是它找不到之前对它下命令的进程，而它手里抱着的数据写进去写失败了，它现在面临着两个选择是接着写呢？还是把这些数据丢弃了呢？结果很显然肯定是丢弃因为你这个进程都不在了我就干脆不写了就偷个懒把数据丢弃了反正你也不知道。

而为了解决这个问题就有一个新状态那就是D状态这个状态是深度睡眠不会被kill掉，所以像刚才那个情况系统再看到一个D状态的会认为它不能被kill掉就算要kill掉也只能等它醒了再kill掉相当于等它处理好它的事情再kill掉它。

![image-20211215133933717](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211215133933717.png)

##### 等待队列

S状态和D状态是当某种任务条件不具备就会被放进等待队列（==wait_queue==）中进行某种等待。

####  阻塞

从运行状态的==task_struct==放到等待队列（==wait_queue==）中就叫做挂起等待（阻塞）

#### 唤醒进程

从等待队列（==wait_queue==）放到运行队列（==run_queue==）被CPU调度就叫做唤醒进程

##### T状态

T状态是暂停也就是相当于操作系统中的挂起，具体就是一个进程正常运行突然cpu发了一个信号通知这个进程，让这个进程停止运行，这个进程就被cpu踢出了运行队列状态同时变成T状态这个时候这个进程就是挂起等待。

##### Z状态

###### 僵尸进程

僵尸进程的意思是这个进程已经死亡了，但是还不能直接结束因为要保存信息和退出码，而操作系统需要先拿到退出码因为操作系统需要知道它是正常死亡还是被kill死亡的，因此操作系统会叫调制器去拿退出码，只要这些信息都被操作系统收到了才会释放资源。

**方便理解的例子：** 一个人在跑步的人（进程）突然猝死，那么死亡后看到的人会报警而警察来了会先获取信息（调制器取信息）让法医判断它是怎么死亡的，然后再把信息带回去才能把人抬走，这些死亡信息会被做成档案存放在警察局。

而这个期间僵尸进程是Z状态，这个状态代表的是进程死了，但是还在运行因为它必须得把信息全交给调制器才会得到结束的信号，我们可以用Linux来模拟下这个僵尸进程。

```c
#include <stdio.h>                                                                                     
#include <stdlib.h>
#include <unistd.h>    
    
int main()    
{    
  size_t id = fork();    
    
  if (!id)    
  {    
    while (1)    
    {    
      printf("pid:%d\n", getpid());    
      sleep(1);    
      exit(EXIT_SUCCESS);    
    }    
    
  }    
  else if (id > 0)    
  {    
    int count = 5;    
    while (count)    
    {    
      printf("ppid:%d\n", getppid());    
      sleep(30);    
      count--;    
    }    
    printf("I am pronc...\n");    
  }    
    
    
  return 0;    
}    
```

![image-20211215144623890](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211215144623890.png)

我们可以看到子进程变成了僵尸进程，因为子进程结束了但是父进程还没结束父进程还没结束就不能去子进程那取退出码，不能取退出码就没法结束就会变成僵尸进程。

###### 僵尸进程的危害

> 进程的退出状态必须维持下去因为它要把它的结果告诉它的父进程，而进程一直不读取，那么子进程就一直是退出状态，维护退出状态是要数据维护的也数据基本信息，所以保存在PCB当中。
>
> 如果父进程创建很多子进程都不回收的话会造成泄露（ps：内存泄露指空间无法被回收利用从导致泄露）

##### X状态

X状态是死亡状态表示这个进程正常结束了。

#### Linux内核状态源代码

```c
/*
* The task state array is a strange "bitmap" of * reasons to sleep. Thus "running" is zero, and * you can test for combinations of others with * simple bit tests.
*/
static const char * const task_state_array[] = 
{ "R (running)",
 /* 0 */ "S (sleeping)",
 /* 1 */ "D (disk sleep)", 
 /* 2 */ "T (stopped)",
 /* 4 */ "t (tracing stop)",
 /* 8 */ "X (dead)",
 /* 16 */ "Z (zombie)",
 /* 32 */
};
```



#### 孤儿进程

如果在子进程是僵尸进程的时候父进程直接终止，那么这个子进程就会成为孤儿进程，而一旦成为孤儿进程那么只能让操作系统来领养。一般是由1号init的进程来领养。

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
int main()
{
    pid_t id = fork();
    if(id < 0){
        perror("fork");
        return 1;
    }
    else if(id == 0){//child
        printf("I am child, pid : %d\n", getpid());
        sleep(10);
    }else{//parent
        printf("I am parent, pid: %d\n", getpid());
        sleep(3);
        exit(0);
    }
    return 0;
}
```

![image-20211215154942230](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211215154942230.png)

#### 同时运行的进程

单核的cpu能同时运行进程吗？答案是可以的

![image-20211215153456029](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211215153456029.png)

```c
 #include <stdio.h>    
  #include <unistd.h>    
      
  int main()    
  {    
    size_t id = fork();    
      
    if (!id)    
    {    
      while (1)    
      {    
        printf("I am chile:%d\n", id);                                                                 
        sleep(1);    
      }    
    }    
    else if(id > 0)    
    {    
      while (1)    
      {    
        printf("I am fathe:%d\n", id);    
        sleep(1);    
      }    
    }    
      
    return 0;    
  }    
```

我们可以看到，它两是同时运行的同时子进程的pid是0，而子生成的子进程自会执行生成它之后的代码，而之上的代码不会执行。

####  进程优先级

##### PRI&Nice

> + PRI是进程优先级，默认值是80值越低优先级越高，值不可被修改。
> + Nice是进程修正值，默认是0它的作用是用于修改优先级
>
> 有时候如果想提升某个进程的效率的话就调整它的优先级，但是相应的代价就是其它进程的运行效率会低，一般是不建议对进程进行优先级调整的默认的就可以了。
>
> 进程的优先级准确的来说是PRI+Nice=进程优先级，而我们对Nice进行修改即可对优先级进行调整，而Nice的值最高是19，最低是-20而PRI默认是80那么进程优先级最高就是99，最低是60。

###### 如何修改Nice

我们使用`top`指令进入实时检测进程，按下r再输入要调整进程的PID，再接着输入调整值如果调整值过低或过高的就得提升权限进行此操作。

###### 进程相关概念

> + 独立性
>
>   每个进程都是隔离的互不影响
>
> + 竞争性
>
>   因为资源有限所以每个进程会有竞争，为了平衡恶意竞争就由进程优先级来限制。
>
> + 并发
>
>   假设cpu是单核，一次只能执行一个进程，而在这段时间内cpu通过切片对多个进程任务进行推进，这段时间内多个进程任务被推进看起来像是同时运行，这个过程我们我们称之为并发。
>
> +    并行
>
>      假设我们有两个及以上的CPU，而这个时候就会有多个进程同时在CPU上运行，那么这个行为我们称之为并行。
>



#### 环境变量

**基础概念：**

> + PATH
>
>   用于指定命令搜索路径（例如：ls这些命令都是通过PATH协助系统搜索路径找到ls的执行程序的）
>
> + HOME
>
>   用于指定工作目录（Linux默认目录指定是home/use，如果不想默认目录就是当前用户可以指定修改）
>
> + SHELL
>
>   当前Shell，通常它都是bin/bash。

###### 查看可执行程序的路径

像ls、rm……这些都是可执行程序，为什么它们都不用./就能执行？而我们却要./才能执行，因为./的意思告诉系统要执行的文件在当前目录内，而为什么那些没有给路径我们却能直接输入文件名就能执行了？其实是环境变量的原因系统要找这些指令的时候会通过PATH来查找因为可执行命令都会放在这，像安装一个程序都要点击下一步，这个过程其实是拷贝它们把程序拷贝到PATH环境变量下这样我们就能输入文件名执行了。

如果我们也想要完成想ls这样直接输入文件名就能执行的操作，我们可以把我们的程序直接拷贝到/usr/bin/目录下，但是不建议在这么做。

真要直接输入程序名就能执行的话我建议用：`export PATH=$PATH:程序所在目录绝对路径`这样添加进去的是临时变量账号一重登就会被删除。

###### 环境变量指令

>+ whics 程序名
>
> 找到该程序的路径
>
>+ export 环境变量名=$环境变量名：绝对路径目录
>
> 用于把可执行程序添加到，环境变量文件内后续可支持直接输入程序名执行改程序，账号一重登就会删除添加的内容
>
>+ export 本地变量名=n
>
> 设置一个新的环境变量不过只在本进程（bash）生效
>
>+ echo 环境变量名
>
> 显示环境变量名路径
>
>+ echo "内容" > /dev/pts/n
>
> 把内容发个另一个使用该机器的人n为使用改机器的显示器端
>
>+ unset 环境变量
>
> 用于清除环境变量
>
>+ set
>
> 用于显示本地定义的Shell变量和环境变量
>
>+ env
>
>  显示所有环境变量

#### 设置永久的环境变量（限个人用户）



>**第一种方式：**
>
>```bash
>vim ~/.bash_profile #用于添加环境变量的配置文件
>vim ~/.bashrc #用于添加环境变量的配置文件
>```
>
>**第二种方式：**
>
>```bash
>/etc/ld.so.conf.d/ #这个目录是系统搜索动态库的一个路径，在这个目录下新增xxx.conf文件，该配置文件里面就是一个路径
>#弄完上述操作要更新缓存
>ldconfig #直接执行更新
>```
>
>

##### 环境变量组织

![image-20211222193312002](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211222193312002.png)

每个程序都会生成一个环境变量表，环境变量表是一个字符指针数组，每个指针指向一个以`\0`结尾的环境字符串。

###### 通过代码获取环境变量

main函数其实是有参数的很多人都不知道，因为一般都用不到但是在Linux下面main函数的参数我们是用的到的，比如可以写个脚本之类的操作，当然windows也是有用的，但是windows主要是以图形界面为主，所以参数几乎无用。

main函数有三个参数且它也是被调用的，分别是`int argc`、`char* argv[]`和`char* envp[]`分别对应的是，指令个数、指令和指令环境变量表。

![image-20211222210407478](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211222210407478.png)

Linux下的指令的选项参数就是这样做出来的，所以mian函数有这些参数是C语言规定的。

##### 进程地址空间

![image-20211222211748124](https://gitee.com/LiangSon/StudyNotesCppC/raw/master/images/image-20211222211748124.png)

以往这叫程序空间地址是不准确的，准确的来讲应该是叫进程空间地址，进程地址空间在Linux内核当中本质一块结构体，在Linux内核中该结构体的名称叫`mm_struct`。

```c
#include <stdio.h>                                                                                                     
#include <unistd.h>
#include <stdlib.h>
                        
int g_val = 0;
                 
int main()
{                      
  pid_t id = fork();
                 
  if (id < 0)
  {                
    perror("fork");
                    
    return 0;                                                  
  }    
  else if (!id)
  {    
    g_val = 100; 
    printf("chilid[%d]:%d：%p\n", getpid(), g_val, &g_val);    
  }    
  else
  {        
    sleep(3);
    printf("parent[%d]:%d：%p\n", getpid(), g_val, &g_val);
  }       
    
  sleep(1);      
    
  return 0;                                   
}         
```

```shell
[ls@VM-4-7-centos test3]$ ./test3
chilid[15274]:100：0x601058
parent[15273]:0：0x601058
[ls@VM-4-7-centos test3]$ 
```



我们可以看到子进程的改变对父进程没有任何影响，说明子进程也是一个独立的PCB，体现了独立性但是空间地址是一样的为什么不会影响呢？

因为地址一样，但是内容改变互不影响说明这不是物理地址而是虚拟地址，因为物理地址具有唯一性如果内容被更改其它进程来读的时候读到的是改变后的内容，而这的子进程的改变对父进程没有任何影响说明这是虚拟地址，虚拟地址通过页表转化就能获得物理地址，这也就说明它们调用的是同一块地址但是改变互不影响。

##### 页表

我们通常看到的地址是真正的地址吗？其实并不是我们能看到的地址都是虚拟地址，物理地址我们是无法看到的因为被操作系统的页表保护起来了。

当我们申请一段空间时操作系统会去物理内存里面找一段闲置空间，然后用页表映射物理空间生成一个虚拟地址。

![image-20220409170846422](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220409170846422.png)

#### 进程地址空间的意义

> 1. 当一个进程进行内存相关的操作的时候进程地址空间可以有效的保护其它进程和自己的数据安全
> 2. 当进程申请了一块空间，操作系统不会第一时间给它物理内存的空间，而是给一个虚拟内存的空间，而当这个进程开始使用申请的内存地址，那么系统才会真正的从物理内存上申请一个块内存，这样做的目的是提高了内存的利用率。
> 3. 每一个进程都认为自己有一个4GB的虚拟内存，从而方便操作系统管理，同时一个进程不可能把所有的虚拟内存都使用完。

## 进程控制

### fork创建子进程

fork是用于创建子进程来完成父进程所交代的任务，当子进程完成某种任务后会有两种返回值一种是父进程调用fork返回的`pid`而另一个才是子进程的返回值`0`，如果子进程返回`-1`说明该进程创建失败。

子进程在生成时操作系统会做几件事，第一创建子进程的信息第二把子进程组织起来连接到`PCB`中从而完成一个进程的创建，而子进程的创建是发生在fork调用的一瞬间吗？

其实并不是，调用fork时它会先让系统创建信息组织信息等等……这一系列操作完成之后才真正的是两个进程这才形成了两个进程，而子进程的数据和代码都是源自于父进程。

如果父进程或子进程的数据发生改变，那么它们将不能公用同一个数据，那么这个时候操作系统会进行写实拷贝来保证进程之间的独立性。

#### 为什么fork能返回两个值？

当一个函数开始返回"返回值时"说明它已经完成了它的核心功能，而fork创建子进程的功能一定是在返回值之前完成了，所以就会有两个返回值。

### 写实拷贝

写实拷贝是发生在子进程的数据和父进程遭到修改才会发生，如果未修改那么会共用一块内存空间这样可以极大的增加空间的利用率，只有但子进程或父进程发生修改时才会独立生成一个块内存，否则都是共用的。

### fork的返回值

+ 父进程调用fork返回子进程的ID

  因为子进程有多个而父进程只有一个且子进程需要被父进程进行管理，所以必须得返回子进程ID才能管理。

+ 子进程的返回值

  当子进程完成某种任务后必须返回执行的结果，所以也会有一个返回值该返回值是给父进程看的，父进程要知道子进程的任务完成的如何。

### fork调用失败

fork调用失败有两种情况：

+ 用户所创建的进程超过了上限
+ 当前系统所存在的进程过多

### 进程终止

#### 为什么main函数要有返回值？

以前从语法角度来讲是不好讲清楚的，但是从操作系统的视角来理解那么就很容易说通了。

因为操作系统必须要返回一个值，这是因为用户要知道该main函数执行的结果如何了，当然有些程序是不需要知道main函数的执行结果但是操作系统必须要提供这样的方式让用户获取到main函数执行的结果且操作系统也得要知道main函数执行的如何。

#### exit

`exit`是用来终止进程的，当进程被`exit`终止那么它会对该进程进行清理释放曾经占有的空间并且会把缓冲区的内容全部刷新出来。

#### _exit

`_exit`和`exit`没有太大的区别，唯一的区别是头文件不同且不会对缓冲区刷新关闭。

#### 进程终止OS做了什么？

当一个进程被`exit`终止那么OS会把它`PCB`和各种队列中移除并释放资源。



### 进程等待

#### 为什么进程要等待？

因为进程不等待的话无法收回子进程的信息，而子进程一直没被收回信息那么回发生僵尸进程且如果长期没被收回会发生内存泄漏问题。

一般进程等待都是由父进程等子进程，父进程等到子进程一般是先进行对子进程的资源回收和退出码等信息回收。

#### 进行进程等待的方法

##### 进程等待的必要性

如果父进程不等待子进程的话会导致子进程成为僵尸进程，而一旦成为僵尸进程就会导致内存泄漏。

##### wait

**函数原型：**

```c
pid_t wait(int* status);
```

##### waitpid

**函数原型：**

```c
pid_t waitpid(pit_t pid, int* status, int options);

返回值：
当正常返回的时候waitpid返回收集到的子进程的进程ID；
如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；
如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；
参数：
pid：
Pid=-1,等待任一个子进程。与wait等效。
Pid>0.等待其进程ID与pid相等的子进程。
status:
WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）
WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）
options:
WNOHANG: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进程的ID。
```

#### 获取子进程status

>+ wait和waitpid，都有一个status参数，该参数是一个输出型参数，由操作系统填充 。
>+ 如果传递NULL，表示不关心子进程的退出状态信息 。
>+ 否则，操作系统会根据该参数，将子进程的退出信息反馈给父进程 。
>+ status不能简单的当作整形来看待，可以当作位图来看待，具体细节如下图（只研究status低16比特
>  位）  

![image-20220928151733203](https://raw.githubusercontent.com/ls02/Image/main/img/image-20220928151733203.png)

**使用案列：**

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <stdlib.h>

int main(void)
{
    pid_t arr[10];
    for (int i = 0; i < 10; i++)
    {
        pid_t id = fork();
        
        if (id == 0)
        {
            int count = 10;
            while (count > 0)
            {
                printf("I am child,pid:%d, ppid: %d\n", getpid(), getppid());
                sleep(1);
                count--;
            }

            exit(11);
        }
        
        arr[i] = id;
    }

    int count = 0;
    while (count < 10)
    {
        int status = 0;
        pid_t ret = waitpid(arr[count], &status, 0);
        
        //以下是推荐的进程等待用法
        if (ret >= 0)
        {
            printf("waite child success!,%d\n", ret);
            if (WIFEXITED(status))
            {
                printf("child get exit code:%d\n", WEXITSTATUS(status));
            }
            else
            {
                printf("child not exit normal!\n");
            }
            //以下是通过未计算来取得信息，低七位是信号退出码，次低八位是进程退出码
            //printf("status: %d\n", status);
            //printf("child get singal:%d\n", status & 0x7F);
            //printf("child get exit code:%d\n", (status >> 8) & 0xFF);
        }

        count++;
    }
    
    return 0;
}
```

#### 进程阻塞和非阻塞的区别

+ 阻塞

  父进程就什么事情都不进行一直等待着子进程，直到子进程成功退出才停止阻塞。

+ 非阻塞

  父进程不会一直等待子进程，而是一直做其它事情每隔一段时间就回来确认子进程是否完成，如果完成那么就会退出非阻塞状态。


### 进程程序替换

用`fork`创建子进程后执行的是父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种`exec`函数来执行另一个程序。

当进程调用一种`exec`函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。

调用`exec`并不创建新进程，所以调用`exec`前后该进程的`id`并未改变。

![image-20220928160757847](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20220928160757847.png)

#### 替换函数

有六种以`exec`开头的函数，统称为`exec`函数：

```c
#include <unistd.h>

int execl(const char* path, const char* arg, ...);
int execlp(const char* file, const char* arg, ...);
int execle(const char* path, const char* arg, ..., char* cosnt envp[]);
int execv(const char* path, char* const argv[]);
int execvp(const char* file, char* const argv[]);
```

#### 函数解释

+ 这些函数如果调用成功则加载新的程序从启动代码开始执行，不再返回。
+ 如果调用出错则返回-1
+ 所以`exec`函数只有出错的返回值，而没有成功的返回值。

![image-20220928181944492](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20220928181944492.png)

![image-20220928182043448](https://raw.githubusercontent.com/ls02/Image/main/img/image-20220928182043448.png)

#### 命令解释

这些函数原型看起来很容易混淆，但只要掌握了规律就很好记住。

+ l(list)：表示参数采用列表
+ v(vector)：参数用数组
+ p(path)；有p自动搜索环境变量`PATH`
+ e(env)：表示自己维护环境变量

#### exec调用例子

```c
#include <unistd.h>
int main()
{
    char *const argv[] = {"ps", "-ef", NULL};
    char *const envp[] = {"PATH=/bin:/usr/bin", "TERM=console", NULL};
    execl("/bin/ps", "ps", "-ef", NULL);
    // 带p的，可以使用环境变量PATH，无需写全路径
    execlp("ps", "ps", "-ef", NULL);
    // 带e的，需要自己组装环境变量
    execle("ps", "ps", "-ef", NULL, envp);
    execv("/bin/ps", argv);
    // 带p的，可以使用环境变量PATH，无需写全路径
    execvp("ps", argv);
    // 带e的，需要自己组装环境变量
    execve("/bin/ps", argv, envp);
    exit(0);
}
```



#### 简易shell实现

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>

#define NUM 1024
#define CMD_NUM 64

int main()
{
    char command[NUM] = { 0 };

    while(1)
    {
        printf("[ls@mydir]## ");
        fflush(stdout);
        fgets(command, NUM, stdin);
        command[strlen(command) - 1] = 0;
        const char* sep = " ";
        char* argv[CMD_NUM] = { NULL };
        int i = 1;
        argv[0] = strtok(command, sep);
        while (argv[i] = strtok(NULL, sep))
        {
            i++;
        }

        if (strcmp(argv[0], "cd") == 0)
        {
            if (argv[1] !=  NULL)
            {
                chdir(argv[1]);
            }
            continue;
        }

        if (fork() == 0)
        {
            execvp(argv[0], argv);
            exit(0);
        }

        int status = 0;
        waitpid(-1, &status, 0);
        printf("等待子进程成功！退出码：%d\n", (status >> 8) & 0xFF);

    }

    return 0;
}
```

# 文件系统

## 文件管理

### 文件描述符

> 文件描述符默认的三个是：0、1和2，这三个是系统默认打开的，0、1和2对应的分别是标准输入、标准输出和标准错误。

### 文件描述使用规则

> 文件描述符是从低到高使用，如果1被关闭了那么下次打开一个文件那么它使用的文件描述符就是1，如果1有人人再使用才会从3开始。
>
> 文件描述符在操作系统是一个数组默认是32个元素大小的数组，但是这32位会根据文件数量增加。

### 内存文件

> 内存文件一般表示文件从磁盘被打开导致被加载到进程从而形成内存文件，因此也可以对此内存文件进行修改等操作、

### 磁盘文件

> 磁盘文件表示存储在磁盘中的文件，它有两个元素构成分别是，文件属性+文件内容。
>
> 文件属性里面存储着元信息，这元信息里面有inode编号、文件占用大小、文件硬链接树、文件拥有者和文件日期等属性。

#### inode

> inode编号是任何一个文件的属性集合，Linux中几乎每一个文件都有一个inode，可能存在大量的inode，区分inode，用inode编号。

![image-20221001172848058](https://raw.githubusercontent.com/ls02/Image/main/img/image-20221001172848058.png)

> Linux ext2文件系统，上图为磁盘文件系统图（内核内存映像肯定有所不同），磁盘是典型的块设备，硬盘分区被划分为一个个的block。一个block的大小是由格式化的时候确定的，并且不可以更改。例如mke2fs的-b选项可以设定block大小为1024、2048或4096字节。而上图中启动块（Boot Block）的大小是确定的
>
> + Block Group：ext2文件系统会根据分区的大小划分为数个Block Group。而每个Block Group都有着相
>   同的结构组成。政府管理各区的例子  
> + 超级块（Super Block）：存放文件系统本身的结构信息。记录的信息主要有：bolck 和 inode的总量，
>   未使用的block和inode的数量，一个block和inode的大小，最近一次挂载的时间，最近一次写入数据的
>   时间，最近一次检验磁盘的时间等其他文件系统的相关信息。Super Block的信息被破坏，可以说整个
>   文件系统结构就被破坏了  
> + GDT，Group Descriptor Table：块组描述符，描述块组属性信息  
> + 块位图（Block Bitmap）：Block Bitmap中记录着Data Block中哪个数据块已经被占用，哪个数据块没
>   有被占用  
> + inode位图（inode Bitmap）：每个bit表示一个inode是否空闲可用。  
> + i节点表:存放文件属性 如 文件大小，所有者，最近改时间等  
> + 数据区：存放文件内容  

将属性和数据分开存放的想法看起来很简单，但实际上是如何工作的呢？我们通过touch一个新文件来看看如何工作。  

```shell
[root@localhost linux]# touch abc
[root@localhost linux]# ls -i abc
263466 abc
```

为了说明问题，我们将上图简化：  

![image-20221001173107918](https://raw.githubusercontent.com/ls02/Image/main/img/image-20221001173107918.png)

创建一个新文件主要有一下4个操作：  

> 1. 存储属性
>    内核先找到一个空闲的i节点（这里是263466）。内核把文件信息记录到其中。
> 2. 存储数据该文件需要存储在三个磁盘块，内核找到了三个空闲块：300,500，800。将内核缓冲区的第一块数据复制到300，下一块复制到500，以此类推。
> 3. 记录分配情况文件内容按顺序300,500,800存放。内核在inode上的磁盘分布区记录了上述块列表。
> 4. 添加文件名到目录新的文件名abc。linux如何在当前的目录中记录这个文件？内核将入口（263466，abc）添加到目录文件。文件名和inode之间的对应关系将文件名和文件的内容及属性连接起来。  

### 硬连接

我们看到，真正找到磁盘上文件的并不是文件名，而是inode。其实在linux中可以让多个文件名对应于同一个inode。  

```shell
[root@localhost linux]# touch abc
[root@localhost linux]# ln abc def
[root@localhost linux]# ls -1i
abc def 263466 abc 263466 def
```

> + abc和def的链接状态完全相同，他们被称为指向文件的硬链接。内核记录了这个连接数，inode263466 的硬连接数为2。  
> + 我们在删除文件时干了两件事情：1.在目录中将对应的记录删除，2.将硬连接数-1，如果为0，则将对应的磁盘释放。  

### 软连接

硬链接是通过inode引用另外一个文件，软链接是通过名字引用另外一个文件，在shell中的做法  

```shell
263563 -rw-r--r--. 2 root root 0 9月 15 17:45 abc
261678 lrwxrwxrwx. 1 root root 3 9月 15 17:53 abc.s -> abc
263563 -rw-r--r--. 2 root root 0 9月 15 17:45 def
```

![image-20221001173509937](https://raw.githubusercontent.com/ls02/Image/main/img/image-20221001173509937.png)

# 动静态库

### 静态库制作

```makefile
libname.a:xxx.o xxx.o
	ar -rc $@ $^
%.o:%.c #'%'代表所有的.o或.c文件
	gcc -c $<

.PHONY:clean
clean:
	rm -rf libname.a *.o output
.PHONY:output
output:
	mkdir output
	cp libname.a output
	cp *.h output
```

### 使用静态库

```shell
gcc xxx.c -I路径 -L路径 -lname
#xxx.c是源文件名，-I路径是指明头文件路径，路径如果是其它目录下的那么就是-I/xxx/xxx
#-L路径是明库的所在路径，路径如果是其它目录下的那么就是-L/xxx/xxx,#-lname是指明要链接哪一个库的名字，比如库名是libname.a，那么我们去掉头lib，再去掉尾部的.a那么库名就是name
```

> 注意：系统的库文件，如c++的和c的库文件都在系统的默认路径下。
>
> 系统默认路径是：/lib64,有的可能是在/usr/lib
>
> 而头文件默认路径：/usr/include等

### 动态库制作

```makefile
libname.so:xxx.o xxx.o
	gcc -shared -o $@ $^ #形成一个动态链接的共享库
%.o:%.c #'%'代表所有的.o或.c文件
	gcc -fPIC -c $<
	
.PHONY:clean
clean:
	rm -f libname.so
	
.PHONY:lib
lib:
	mkdir lib
	cp *.h lib
	cp libname.so lib
```

#### 使用动态库

```makefile
mytest:test.c
	gcc -o $@ $^ -I路径 -L路径 -l库名
.PHONY:clean
clean:
	rm -rf mytest
```

注意：如果要运行动态库的程序，需要在运行的时候进一步告知，系统我的库在哪里。

```shell
#LD_LIBRARY_PATH -》指明程序启动之后，库的搜索路径
export LD_LIBRARY_PATH=库的具体路径 #设置环境变量
ldd 程序名 #用于查看程序的链接路径
```



# 进程间通信

> 在有些场景下我们需要进程之间协同完成某种任务，而每个进程都是具有独立性的，那么如何完成进程之间的通信呢？
>
> 我们要知道进程间如何通信首先得知道它们为何不能通信，因为每个进程的数据互相是看不到的，如果看不到互相之间的数据那么如何完成通信呢？
>
> 我们可以借助一种公共资源来让双方看到对方，而这个公共资源也是通信的必要条件之一。

## 匿名管道

> 我们知道fork出来的子进程是会拷贝父进程的所有相关数据的，那么如果我们在创建子进程之前打开一个文件，那么子进程也会跟父进程拥有相同的文件描述符，那么我们是不是就可以通过这个来完成通信了呢？因为我们看到了同一个公共资源，也就是文件描述符。
>
> 其实仅仅看到同一个文件描述符是不行的，因为你打开一个文件描述符的时候需要使用`R`或`W`方式打开，那么这样的话无法进行通信，通信的前提是一端负责写，一端负责读，这样才能通信就跟我们人与人之间交流一样。
>
> 所以我们可以借助`pipe`函数来获得读和写的文件描述符，这样的话就可以完成进程之间的通信了，而`pipe`的参数是一个输出型参数，所以没我们需要一个数组来保存，因为它会给两个值。
>
> pipe[0]是读，pipe[1]是写，而管道通信是单向通信，不能双向所以一个进程要写的话，那么它要关闭它的读端，另一个进程也是同理。
>
> **使用代码：**
>
> ```c
> #include <stdio.h>
> #include <sys/types.h>
> #include <fcntl.h>
> #include <unistd.h>
> #include <stdlib.h>
> #include <sys/wait.h>
> 
> 
> int main()
> {
>     int pipe_fd[2] = { 0 }; 
> 
>     if (pipe(pipe_fd) < 0)
>     {
>         perror("pipe\n");
>         
>         return 1;
>     }
> 
>     pid_t id = fork();
>     if (id == 0)
>     {
>         close(pipe_fd[0]);
>         int count = 0;
> 
>         //while (1)
>         //{
>         //    const char* str = "hello";
>         //    write(pipe_fd[1], str, sizeof(str));
>         //    printf("写端:%d\n", count);
>         //    //sleep(1);
>         //    count++;
>         //}
> 
>         sleep(10);
> 
>         close(pipe_fd[1]);
> 
>         exit(0);
>     }
> 
>     close(pipe_fd[1]);
>     char str[1024] = { 0 };
>     while (1)
>     {
>         printf("开始读取\n");
> 
>         int ret = read(pipe_fd[0], str, sizeof(str) - 1);
>         sleep(2);
> 
>         if (ret > 0)
>         {
>             printf("读取成功: %s\n", str);
>         }
>         else if (ret == 0)
>         {
>             printf("读取完毕\n");
>             break;
>         }
>         else 
>         {
>             perror("读取失败!\n");
>             break;
>         }
>     }
> 
>     sleep(5);
>     int stat = 0;
>     waitpid(-1, &stat, 0);
>     printf("退出码:%d\n", (stat >> 8) & 0xFF);
>     printf("退出信号: %d\n", stat & 0x7f);
>     close(pipe_fd[0]);
> 
>     return 0;
> }
> 
> ```

**总结：**

> 1. 管道是一个只能单向通信的信道
> 2. 管道是面向字节流的
> 3. 仅限于父子通信
> 4. 管道自带同步机制，原子性写入
>
> **管道的四种情况：**
>
> + 读端不读或读的慢，写端要等读端
> + 读端关闭，写端收到SIGP IPE信号直接终止
> + 写端不写或写的慢，读端要等写端
> + 写端关闭，写端读完pipe内部的数据然后再继续读，会读到0，表明读到文件结尾。

## 命名管道

> 命名管道其实就是创建一个管道文件，让没有血缘关系的不同进程进行通信，我们也知道想让不同的进程进行通信得让它们双方看到一个公共的资源，那么我们可以用`mkfifo`来创建一个管道文件，从而使得它们之间能互相看见这样就能进行通信了。
>
> **使用方法：**
>
> ==server.c==
>
> ```c
> #include "comm.h"
> 
> int main()
> {
>     umask(0);
>     if (mkfifo(MY_FIFO, 0666) < 0)
>     {
>         perror("mkfifo\n");
> 
>         return 1;
>     }
> 
>     int fd = open(MY_FIFO, O_RDONLY);
>     if (fd < 0)
>     {
>         perror("open!\n");
> 
>         return 2;
>     }
> 
>     //读取业务
> 
>     while (1)
>     {
>         char str[1024] = { 0 };
>         int ret = read(fd, str, sizeof(str) - 1);
>         if (ret > 0)
>         {
>             printf("读取成功：%s\n", str);
> 
>             if (strcmp(str, "ls") == 0)
>             {
>                 if (fork() == 0)
>                 {
>                     execlp("ls", "-l", "-a", NULL);
> 
>                     exit(0);
>                 }
>             }
>         }
>         else if (0 == ret)
>         {
>             printf("读取到文件结尾!\n");
>             break;
>         }
>         else 
>         {
>             perror("读取失败！\n");
>             break;
>         }
>     }
> 
>     close(fd);
> 
>     return 0;
> }
> 
> ```
>
> ==comm.h==
>
> ```c
> #include <stdio.h>
> #include <sys/types.h>
> #include <fcntl.h>
> #include <unistd.h>
> #include <stdlib.h>
> #include <sys/wait.h>
> #include <sys/stat.h>
> #include <string.h>
> 
> #define MY_FIFO "./fifo"
> 
> ```
>
> ==client.c==
>
> ```c
> #include "comm.h"
> 
> int main()
> {
>    int fd = open(MY_FIFO, O_WRONLY); 
>    if (fd < 0)
>    {
>        perror("open\n");
>        
>        return 1;
>    }
> 
>    //写入业务
>     while (1)
>     {
>         char str[1024] = { 0 };
>         printf("请输入:");
>         fflush(stdout);
>         ssize_t s = read(0, str, sizeof(str) - 1);
>         if (s > 0)
>         {
>             str[s - 1] = 0;
>             printf("client: %s\n", str);
> 
>             write(fd, str, strlen(str));
>         }
>     }
> 
>    close(fd);
> 
>    return 0;
> }
> ```

### 管道特点

> + 只能用于具有共同祖，先的进程（具有亲缘关系的进程）之间通信，通常一个管道由一个进程创建，然后该进程调用fork，此后父子进程之间就可以用管道通信。
> + 管道提供流式服务
> + 一般而言，进程退出，管道释放，所以管道的生命周期随进程。
> + 一般而言，内核会对管道操作进行同步与互斥操作
> + 管道是半双工的，数据只能向一个方向流动，需要双方通信时建立两个管道。
>
> ![image-20230208182041127](https://raw.githubusercontent.com/ls02/Image/main/img/202302081820014.png)

## 共享内存

共享内存区时最快的IPC形式，一旦这样的内存映射到共享内存它的进程的地址空间，这些进程间数据传递不再涉及到内核，换句话说就是进程不在通过执行内核的系统调用来传递彼此的数据。

![image-20230208182255595](https://raw.githubusercontent.com/ls02/Image/main/img/202302081822585.png)

### 共享内存函数



shmget函数

```c
功能：用来创建共享内存
原型
	int shmget(key_t key, size_t size, int shmflg);
参数
	key:这个共享内存段名字
	size:共享内存大小
	shmflg:由九个权限标志构成，它们的用法和创建文件时使用的mode模式标志是一样的,一般用IPC_CREAT和IPC_EXCL.
返回值：成功返回一个非负整数，即该共享内存段的标识码；失败返回-1,
```

shmat函数

```c
功能：将共享内存段连接到进程地址空间
原型
	void *shmat(int shmid, const void *shmaddr, int shmflg);
参数
	shmid: 共享内存标识
	shmaddr:指定连接的地址
	shmflg:它的两个可能取值是SHM_RND和SHM_RDONLY
返回值：成功返回一个指针，指向共享内存第一个节；失败返回-1
```

**说明：**

```c
shmaddr为NULL，核心自动选择一个地址
shmaddr不为NULL且shmflg无SHM_RND标记，则以shmaddr为连接地址。
shmaddr不为NULL且shmflg设置了SHM_RND标记，则连接的地址会自动向下调整为SHMLBA的整数倍。公式：shmaddr -
(shmaddr % SHMLBA)
shmflg=SHM_RDONLY，表示连接操作用来只读共享内存
```

shmat函数

```c
功能：将共享内存段与当前进程脱离
原型
	int shmdt(const void *shmaddr);
参数
	shmaddr: 由shmat所返回的指针
返回值：成功返回0；失败返回-1
注意：将共享内存段与当前进程脱离不等于删除共享内存段
```

shmctl函数

```c
功能：用于控制共享内存
原型
	int shmctl(int shmid, int cmd, struct shmid_ds *buf);
参数
	shmid:由shmget返回的共享内存标识码
	cmd:将要采取的动作（有三个可取值）
	buf:指向一个保存着共享内存的模式状态和访问权限的数据结构
返回值：成功返回0；失败返回-1
```

![image-20230208182721231](https://raw.githubusercontent.com/ls02/Image/main/img/202302081827871.png)

**使用代码：**

client.c

```c
#include "comm.h"

int main()
{
    //通过算法来生成唯一的key,再用这个key生成一个shmid
    key_t key = ftok(PATH_NAME, PROJ_ID);
    if (key < 0)
    {
        perror("ftok\n");

        return 1;
    }

    //获取共享内存ID
    int shmid = shmget(key, SIZE, IPC_CREAT);
    if (shmid < 0)
    {
        perror("shmid\n");

        return 2;
    }

    //关联共享内存
    char* mem = (char*)shmat(shmid, NULL, 0); 

    //向共享内存写入数据
    
    int i = 0;
    while (i < 5)
    {
        sleep(1);
        mem[i] = 'a';
        i++;
        mem[i] = 0;
    }

    sleep(10);

    shmdt(mem);

    return 0;
}

```

server.c

```c
#include "comm.h"

int main()
{
    //通过ftok生成一个唯一 key
    key_t key = ftok(PATH_NAME, PROJ_ID);
    if (key < 0)
    {
        perror("ftok\n");

        return 1;
    }

    //获得shmid
    //如果存在就返回当前的共享内存，如果不存在就创建并且得到一个最新的没有人使用过的
    int shmid = shmget(key, SIZE, IPC_CREAT | IPC_EXCL | 0666);
    if (shmid < 0)
    {
        perror("shmid\n");

        return 2;
    }
    //将进程和共享内存关联
    char* mem = (char*)shmat(shmid, NULL, 0);
    
    //业务逻辑区
    while (1)
    {
        sleep(1);
        printf("%s\n", mem);
    }

    //去关联
    shmdt(mem);

    //把共享内存从内核区删掉
    shmctl(shmid, IPC_RMID, NULL);

    return 0;
}

```

comm.h

```c
#include <stdio.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/shm.h>

#define MY_FIFO "./fifo"
#define SIZE 4096
#define PROJ_ID 0x5555
#define PATH_NAME "./"

```

# 信号

> 信号是进程之间时间异步通知的一种方式，属于软中断。

## 信号处理常见方式

分别有三种动作：

1. 忽略动作
2. 默认动作
3. 提供一个信号处理函数，要求内核在处理该信号的时切换到用户态执行这个处理函数，这种方式称为捕捉信号

### signla函数

> 该函数是一个捕捉信号的处理函数，它把捕获到的信号按照用户自定义的方式处理，它可以捕获31种信号，不能捕捉9号信号。
>
> 它有两个参数，一个整形代表要捕获的信号，一个函数指针类型代表自定义处理的函数。

### 进程为什么会崩溃？

> 当一个进程崩溃会收到一个信号，而这个信号的发起者是操作系统，那么操作系统为什么会发信号给该进程，首先我们要知道操作系统是硬件的管理者，它的主要职责是来保护硬件的安全，而我们的进程是把代码交给CPU处理，而处理的时候操作系统发现这个代码会让CPU处理出现错误，那么操作系统会终止这段代码的执行同时向该进程发起对应的信号。

### 信号产生的方式

1. 键盘产生
2. 进程异常产生
3. 系统调用产生
4. 软件条件产生

### 理解操作系统给进程发送信号的过程

> 操作系统给进程发送信号的本质就是把对应的task_struct(进程控制块)的信号位图中写入比特位1，就是信号发送的动作。
>
> 而进程是如何识别信号的？
>
> 进程能识别信号其实就是预先设计好了几个固定的信号，也就是在task_struct当中定义了一个==uint32_t sigs;==变量，它是一个位图结构用来记录是否收到信号，如果收到信号说明是操作系统把该变量里面的对应的比特位置为了1。

#### 信号的其它相关概念

> + 实际执行信号的处理动作称为信号递达
>
>   自定义捕捉，默认和忽略这三种动作就是递达的一种现象
>
> + 信号从产生到递达之间的状态，称为信号未决
>
>   本质就是这个信号被暂时存放在 task_struct 信号位图中，未决。
>
> + 进程可以选择阻塞某个信号
>
>   本质就是OS，允许进程暂时屏蔽指定的信号，该信号依旧是未决，该信号也不会被递达直到解除阻塞，才可递达。
>
> + 被阻塞的信号产生时将保持在未决状态，直到进程解除对信号的阻塞。
>
> + 注意阻塞和递达忽略是不同的，阻塞不会被递达，独立状态，而递达忽略是已经递达了，但是它的动作是忽略；

![image-20230211171142372](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20230211171142372.png)

### core_dump

如果我们的进程遇到异常结束那么一定会收到一个信号，那么我想知道具体是哪里引发了该信号，我们可以通过core_dump文件来确定，云服务器默认是关闭的，如果打开了那么遇到信号终止的会产生一个core_dump文件，该文件记录代码的出错行，我们只需要用gdb把该文件导入就可以看到了。

+ pending

  保存的是已经收到了信号，但是没有被递达的信号。

  OS发送信号本质：修改目标进程的pending位图。

+ block

  状态位图，表示那些信号不应该被递达，直到解除阻塞。

+ handler

  函数指针数组，[31]，每个信号编号就是该数组的下标。

# 多线程

## 什么是线程？

线程就是一个执行流，也叫轻量级进程它没有创建一个进程来维护自己的相关数据而是延用了进程的资源来维护自己的相关数据

## 线程和进程的区别

+ 线程是调度的基本单位
+ 进程是承担资源分配的基本单位
+ 线程共享进程数据，但是也有自己一部分的数据：
  + 线程ID
  + 一组寄存器
  + 栈
  + errno
  + 信号屏蔽字
  + 调度优先级

**总结：** 线程大部分数据是共享的但也有一部分资源是私有的比如：上下文和栈，进程是独立的只有部分资源是共享的比如：管道。

## 线程的优点

> + 创建一个新线程的代价要比创建一个新进程小得多
> + 线程与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少得多
> + 线程占用的资源要比进程少
> + 在等待慢速I/O操作结束的同时，程序可执行其它的计算任务
> + I/O密集型应用，为了提高性能，将I/O操作重叠，线程可以同时等待不同的I/O操作
> + 计算密集型应用，为了能在多处理器系统上运行，将计算任务分解到多个线程中实现。

## 线程的缺点

> + 性能损失
>
>   一个很少被外部事件阻塞的计算密集型线程往往无法与其它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和协调开销，而可用的资源不变
>
> + 健壮性降低
>
>   编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。
>
> + 缺乏访问控制
>
>   进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。
>
> + 编程难度提高
>
>   编写与调试一个多线程程序比单线程程序困难得多。

## 线程异常的影响

> + 单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随之崩溃。
> + 线程是进程的执行分支，线程出现异常就类似进程出现异常，进而触发信号机制，终止进程，该进程内的所有线程也就随即退出。

## 线程的用途

> + 合理的使用多线程，能提高CPU密集型程序的执行效率。
> + 合理的使用多线程，能提高IO密集型程序的用户体验。

## 创建线程

```c
功能：创建一个新的线程
原型
	int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *
(*start_routine)(void*), void *arg);
参数
	thread:返回线程ID
	attr:设置线程的属性，attr为NULL表示使用默认属性
	start_routine:是个函数地址，线程启动后要执行的函数
arg:传给线程启动函数的参数
返回值：成功返回0；失败返回错误码
```

**错误检查：**

> + 传统的一些函数是成功返回0，失败返回-1，并且对全局变量errno赋值以指示错误。
> + `pthreads`函数出错时不会设置全局变量errno（而大部分其它POSIX函数会这样做），而是将错误代码通过返回值返回
> + `pthreads`同样也提供了县城内的errno变量，以支持其它使用`errno`的代码，对于`pthreads`函数的错误，建议通过返回值业判定，因为读取返回值要比读取线程内的errno变量的开销更小。

## 线程终止

```c
功能：线程终止
原型
	void pthread_exit(void *value_ptr);
参数
	value_ptr:value_ptr不要指向一个局部变量。
返回值：无返回值，跟进程一样，线程结束的时候无法返回到它的调用者（自身）
```

### 线程取消

```c
功能：取消一个执行中的线程
原型
	int pthread_cancel(pthread_t thread);
参数
	thread:线程ID
返回值：成功返回0；失败返回错误码
```

### 线程等待

```c
功能：等待线程结束
原型
	int pthread_join(pthread_t thread, void **value_ptr);
参数
	thread:线程ID
	value_ptr:它指向一个指针，后者指向线程的返回值
返回值：成功返回0；失败返回错误码
```

### 进程分离

> + 默认情况下，新创建的线程是`joinable`的，线程退出后，需要对其进行`ptread_join`操作，否则无法释放资源，从而造成内存泄漏。
> + 如果不关心线程的返回值，join是一种负担，这个时候我们可以告诉系统，当线程退出时自动释放资源。

```c
int pthread_detach(pthread_t thread)
```

## 线程的相关概念

+ 临界资源

  凡是被线程共享访问的资源都是临界资源

+ 临界区

  访问临界资源的代码片段就是临界区

+ 互斥

  在任意时刻只能有一个执行流访问某段代码或访问部分资源

+ 原子性

  一个事情只有两种状态只有把事情办好了和把事情把砸了，不存在这个事情还在办。

+ 同步

  让多个执行流访问临界资源的过程是在线程安全的前提让这些执行流具有一定的顺序性。

## 可重入和线程安全

### 概念

> + 线程安全
>
>   多个线程并发同一段代码时，不会出现不同的结果，常见对全局变量或静态变量进行操作，并且没有锁保护的情况下，会出现该问题。
>
> + 重入
>
>   同一个函数被不同的执行流调用，当前一个流程还没有执行完就有其它的执行流再次进入，我们称之为重入，一个函数在重入的情况下，运行结果不会出现任何不同或者任何问题，则该函数称为可重入函数，否则是不可重入函数。

### 常见的线程不安全的情况

> + 不保护共享变量的函数、
> + 函数状态随着被调用，状态发生变化的函数
> + 返回指向静态变量指针的函数
> + 调用线程不安全函数的函数

### 常见的线程安全的情况

> + 每个线程对全局变量或静态变量只有读取的权限，一般来说这些线程是安全的
> + 类或者接口对于线程来说都是原子操作
> + 多个线程之间的切换不会导致该接口的执行结果存在二义性。

### 常见不可重入的情况

> + 调用了malloc/free函数，因为`malloc`函数是用全局链表来管理堆的。
> + 调用标准I/O库函数，标准i/O库的很多实现都以不可重入的方式使用全局数据结构
> + 可重入函数体内使用了静态的数据结构

### 常见可重入的情况

> + bu使用全局变量或静态变量
> + 不适用`malloc`或者`new`开辟出的空间
> + 不调用不可重入函数
> + 不返回静态或全局数据，所有数据都有函数的调用者提供
> + 使用本地数据或者通过制作全局数据的本地拷贝来保护全局数据

### 可重入与线程安全联系

> + 函数是可重入的，那就是线程安全的
> + 函数是不可重入的，那就不能由多个线程使用，有可能引发线程安全问题
> + 如果一个函数中有全局变量，那么这个函数既不是线程安全的也不是可重入的

### 可重入与线程安全区别

> + 可重入函数是线程安全的一种
> + 线程安全不一定是可重入的，而可重入函数则一定是线程安全的。
> + 如果将对临界资源的访问加上锁，则这个函数是线程安全的，但如果这个重入函数若锁还未释放则会产生死锁，因此是不可重入的。

## 常见锁概念

### 死锁

> + 死锁是指在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其它进程所占用不会释放的资源而处于的一种永久等待状态。

### 死锁的四个必要条件

> + 互斥条件
>
>   一个资源每次只能被一个执行流执行
>
> + 请求与保持条件
>
>   一个执行流因请求资源而阻塞时，对已获得的资源保持不放
>
> + 不剥夺条件
>
>   一个执行流已获得的资源，在未使用完之前，不能强行剥夺
>
> + 循环等待条件
>
>   若干执行流之间形成一种头尾相接的循环等待资源的关系

### 避免死锁

> + 破坏死锁的四个必要条件
> + 加锁顺序一致
> + 避免锁未释放的场景
> + 资源一次性分配

## 条件变量

> 条件变量主要使用完成同步的，让多线程具有一定的顺序性。

### 条件变量函数初始化

```c
int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict
attr);
参数：
	cond：要初始化的条件变量
	attr：NULL
```

### 销毁

```c
int pthread_cond_destroy(pthread_cond_t *cond)
```

### 等待条件满足

```c
int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex);
参数：
	cond：要在这个条件变量上等待
	mutex：互斥量，必须要给个锁地址，条件变量一般都是搭配互斥锁使用。
```

### 唤醒等待

```c
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_signal(pthread_cond_t *cond);
```

### 为什么`pthread_cond_wait`需要互斥量？

> + 条件等待是线程间同步的一种手段，如果只有一个线程，条件不满足，一直等下去都不会满足，所以必须要有一个线程通过某些操作，改变共享变量，使原先不满足的体哦挨肩变得满足，并且友好的通知等待在条件变量上的线程。
> + 条件不会无缘无故的突然变得满足了，必然会牵扯到共享数据的变化，所以一定要用互斥锁来保护，没有互斥锁就无法安全的获取和修改共享数据。
>
> ![image-20230215001014499](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20230215001014499.png)

## 生产者消费者模型

生产者消费者模型就像我们生活当中的超市，超市是以一个中转站负责从生产者那进货来存储以供消费者消费。

### 321原则

三种关系：

+ 消费者和消费者

  竞争和互斥

+ 消费者生产者

  互斥和同步

+ 生产者和生产者

  竞争和互斥

两种角色：

1. 生产者
2. 消费者

一种交易场所：用于缓存生产者的数据以供消费者消费。

**单一数据的生产者消费者代码：**

`BlockQueue.hpp`

```c
#ifndef __BLOCK_QUEUE_HPP__
#define __BLOCK_QUEUE_HPP__

#include <iostream>
#include <queue>
#include <pthread.h>
#include <time.h>
#include <unistd.h>

namespace ls
{
    const int defcap = 5;
    template<class T>
    class BlockQueue 
    {
        private:
            int _cap; //容量
            std::queue<T> _bq; //交易场所
            pthread_mutex_t mtx;
            pthread_cond_t _full; //满的消费者在该条件变量下等待
            pthread_cond_t _empty; //空的生产者在该条件变量下等待

        private:
            bool IsFull()
            {
                return _bq.size() == _cap;
            }

            bool IsEmpty()
            {
                return _bq.size() == 0;
            }
        public:
            BlockQueue(int cap = defcap)
                :_cap(cap)
            {
                pthread_mutex_init(&mtx, nullptr);
                pthread_cond_init(&_full, nullptr);
                pthread_cond_init(&_empty, nullptr);
            }

            ~BlockQueue()
            {
                pthread_mutex_destroy(&mtx);
                pthread_cond_destroy(&_full);
                pthread_cond_destroy(&_empty);
            }

            void Lock()
            {
                pthread_mutex_lock(&mtx);
            }

            void UnLock()
            {
                pthread_mutex_unlock(&mtx);
            }

            void ProducerWait()
            {
                pthread_cond_wait(&_full, &mtx);
            }

            void ConsumerWait()
            {

                pthread_cond_wait(&_empty, &mtx);
            }

            void ProducerWakeUp()
            {
                pthread_cond_signal(&_full); 
            }

            void ConsumerWakeUp()
            {
                pthread_cond_signal(&_empty);
            }

            //生产者生产数据
            void Push(const T& in)
            {
                Lock();
                //如果生产者满了停止生产
                while (IsFull())
                {
                    ProducerWait();
                }
                _bq.push(in);
                UnLock();
                ConsumerWakeUp();
            }


            //消费者消费数据
            void Pop(T* out)
            {
                Lock();
                while (IsEmpty())
                {
                    ConsumerWait();
                }
                *out = _bq.front();
                _bq.pop();
                sleep(3);
                UnLock();
                ProducerWakeUp();
            }
    };
}

#endif

```



`test.c`

```c
#include "BlockQueue.hpp"

//生产者不停生产数据
void* WorkProducer(void* args)
{
    ls::BlockQueue<int>* bq = (ls::BlockQueue<int>*)args;

    while (true)
    {
        int data = rand() % 20 + 1;
        bq->Push(data);

        std::cout << "生产者：" << data << std::endl;
    }
}

//消费者不停消费数据
void* WorkConsumer(void* args)
{
    ls::BlockQueue<int>* bq = (ls::BlockQueue<int>*)args;

    while (true)
    {
        int data = 0;
        bq->Pop(&data);
        std::cout << "消费者：" << data << std::endl;
    }
}

int main()
{
    srand((size_t)time(nullptr));
    ls::BlockQueue<int>* bq = new ls::BlockQueue<int>();

    pthread_t producer;
    pthread_t consumer;

    pthread_create(&producer, nullptr, WorkProducer, (void*)bq);
    pthread_create(&consumer, nullptr, WorkConsumer, (void*)bq);

    pthread_join(producer, nullptr);
    pthread_join(consumer, nullptr);

    return 0;
}

```

处理各种数据版本的消费者生产者模型

`BlockQueue`

```c
#ifndef __BLOCK_QUEUE_HPP__
#define __BLOCK_QUEUE_HPP__

#include <iostream>
#include <queue>
#include <pthread.h>
#include <time.h>
#include <unistd.h>

namespace ls
{
    const int defcap = 5;
    template<class T>
    class BlockQueue 
    {
        private:
            int _cap; //容量
            std::queue<T> _bq; //交易场所
            pthread_mutex_t mtx;
            pthread_cond_t _full; //满的消费者在该条件变量下等待
            pthread_cond_t _empty; //空的生产者在该条件变量下等待

        private:
            bool IsFull()
            {
                return _bq.size() == _cap;
            }

            bool IsEmpty()
            {
                return _bq.size() == 0;
            }
        public:
            BlockQueue(int cap = defcap)
                :_cap(cap)
            {
                pthread_mutex_init(&mtx, nullptr);
                pthread_cond_init(&_full, nullptr);
                pthread_cond_init(&_empty, nullptr);
            }

            ~BlockQueue()
            {
                pthread_mutex_destroy(&mtx);
                pthread_cond_destroy(&_full);
                pthread_cond_destroy(&_empty);
            }

            void Lock()
            {
                pthread_mutex_lock(&mtx);
            }

            void UnLock()
            {
                pthread_mutex_unlock(&mtx);
            }

            void ProducerWait()
            {
                pthread_cond_wait(&_full, &mtx);
            }

            void ConsumerWait()
            {

                pthread_cond_wait(&_empty, &mtx);
            }

            void ProducerWakeUp()
            {
                pthread_cond_signal(&_full); 
            }

            void ConsumerWakeUp()
            {
                pthread_cond_signal(&_empty);
            }

            //生产者生产数据
            void Push(const T& in)
            {
                Lock();
                //如果生产者满了停止生产
                while (IsFull())
                {
                    ProducerWait();
                }
                _bq.push(in);
                UnLock();
                ConsumerWakeUp();
            }


            //消费者消费数据
            void Pop(T* out)
            {
                Lock();
                while (IsEmpty())
                {
                    ConsumerWait();
                }
                *out = _bq.front();
                _bq.pop();
                UnLock();
                ProducerWakeUp();
            }
    };
}

#endif

```

`test.c`

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>

#define NUM 5

pthread_mutex_t mutex;

int titke = 1000;

void* PthreadRun(void* argv)
{
    int num = *(int*)argv;
    free(argv);
    while (titke > 0)
    {
        pthread_mutex_lock(&mutex);
        if (titke > 0)
        {
            printf("抢票成功,我是线程[%d]: %d\n", num, titke); 
            usleep(1000);
            --titke;
        }
        else 
        {
            printf("抢票失败,我是线程[%d]\n", num);
        }
        pthread_mutex_unlock(&mutex);
    }

   return (void*)1;
}

int main()
{
    pthread_t tid[NUM];
    pthread_mutex_init(&mutex, NULL);
    
    for (int i = 0; i < NUM; i++)
    {
        int* num = (int*)malloc(sizeof(int));
        *num = i;
        pthread_create(&tid[i], NULL, PthreadRun, (void*)num);
    }

    for (int i = 0; i < NUM; i++)
    {
        pthread_join(tid[i], NULL);
    }

    pthread_mutex_destroy(&mutex);

    return 0;
}

```

## 信号量

### 概念

> 信号量本质就是一个计数器，描述临界资源在红数目的大小（最多能有多少资源分配给线程）

### POSIX信号量

> POSIX信号量和SystemV信号量作用相同，都是用于同步操作，达到无冲突的访问共享资源的目的，但POSIX可以用于线程间同步。

#### 初始化信号量

```c
#include <semaphore.h>
	int sem_init(sem_t *sem, int pshared, unsigned int value);
参数：
	pshared:0表示线程间共享，非零表示进程间共享
	value：信号量初始值
```

#### 销毁信号量

```c
int sem_destroy(sem_t *sem);
```

#### 等待信号量

```c
功能：等待信号量，会将信号量的值减1
int sem_wait(sem_t *sem); //P()
```

#### 发布信号量

```c
功能：发布信号量，表示资源使用完毕，可以归还资源了。将信号量值加1。
int sem_post(sem_t *sem);//V()
```

### PV操作

#### P操作

> P操作是用于申请一个信号量，当被申请了一个信号量，那么`count`--，进而表示信号量减一，因为被占用了一个信号量所以减1

#### V操作

> V操作是用于释放信号量，当被申请的信号量不适用的时候就用V操作，那么`count`--，进而表示信号量一，因为信号量被释放了所以加1

## 基于环形队列的生产者消费者模型

`RingQueue.hpp`

```cpp
#ifndef  __RING_QUEUE_HPP__
#define __RING_QUEUE_HPP__

#include <iostream>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>
#include <vector>

const int g_cap_default = 10;

template<class T>
class RingQueue 
{
    private:
        //生产者关心有没有空位置
        sem_t _blank_sem;
        //消费者关心有没有数据
        sem_t _data_sem;

        //环形队列
        std::vector<T> _ring_queue;
        //环形队列的大小
        int _cap;

        int _v_step;
        int _p_step;
    public:
        RingQueue(int cap = g_cap_default)
            :_cap(cap)
             ,_ring_queue(cap)
    {
        sem_init(&_blank_sem, 0, cap);
        sem_init(&_data_sem, 0, 0);
        _v_step = _p_step = 0;
    }

        ~RingQueue()
        {
            sem_destroy(&_blank_sem);
            sem_destroy(&_data_sem);
        }

    public:
        void Push(const T& in)
        {
            //生产前需要先申请一个信号量也就是P操作才能开始生产
            sem_wait(&_blank_sem);//P（空位置）
            //开始生产
            _ring_queue[_p_step] = in;
            sem_post(&_data_sem);//V（数据）
            _p_step++;
            _p_step %= _cap;
        }

        void Pop(T* out)
        {
            //消费接口
            sem_wait(&_data_sem);//P
            *out = _ring_queue[_v_step];
            sem_post(&_blank_sem);//V

            _v_step++;
            _v_step %= _cap;
        }
};

#endif

```

`test.cc`

```cpp
#include "RingQueue.hpp"
#include <time.h>

//消费者
void* Consumer(void* args)
{

    RingQueue<int>* q = (RingQueue<int>*)args;
    while (true)
    {
        int data = 0;
        q->Pop(&data);
        std::cout << "消费者消费数据：" << data << std::endl;
    }
}

//生产者
void* Producter(void* args)
{
    RingQueue<int>* q = (RingQueue<int>*)args;
    while (true)
    {
        int data = rand() % 20 + 1;
        std::cout << "生产者生产数据：" << data << std::endl;
        q->Push(data);
        sleep(1);
    }
}

int main()
{
    srand((size_t)time(nullptr));
    pthread_t p1;
    pthread_t p2;

    RingQueue<int>* q = new RingQueue<int>();

    pthread_create(&p1, nullptr, Consumer, (void*)q);
    pthread_create(&p2, nullptr, Producter, (void*)q);
    

    pthread_join(p1, nullptr);
    pthread_join(p2, nullptr);
    
    return 0;
}

```

#### 多消费者多生产者实现的环形队列

`RingQueue.hpp`

```cpp
#ifndef  __RING_QUEUE_HPP__
#define __RING_QUEUE_HPP__

#include <iostream>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>
#include <vector>

const int g_cap_default = 10;

template<class T>
class RingQueue 
{
    private:
        //生产者关心有没有空位置
        sem_t _blank_sem;
        //消费者关心有没有数据
        sem_t _data_sem;

        //环形队列
        std::vector<T> _ring_queue;
        //环形队列的大小
        int _cap;

        int _v_step;
        int _p_step;

        pthread_mutex_t _v_mtx;
        pthread_mutex_t _p_mtx;
    public:
        RingQueue(int cap = g_cap_default)
            :_cap(cap)
             ,_ring_queue(cap)
    {
        sem_init(&_blank_sem, 0, cap);
        sem_init(&_data_sem, 0, 0);
        _v_step = _p_step = 0;
    }

        ~RingQueue()
        {
            sem_destroy(&_blank_sem);
            sem_destroy(&_data_sem);
        }

    public:
        void Push(const T& in)
        {
            //生产前需要先申请一个信号量也就是P操作才能开始生产
            sem_wait(&_blank_sem);//P（空位置）

            pthread_mutex_lock(&_p_mtx);
            //开始生产
            _ring_queue[_p_step] = in;
            _p_step++;
            _p_step %= _cap;
            pthread_mutex_unlock(&_p_mtx);
            sem_post(&_data_sem);//V（数据）
        }

        void Pop(T* out)
        {
            //消费接口
            sem_wait(&_data_sem);//P

            pthread_mutex_lock(&_v_mtx);
            *out = _ring_queue[_v_step];

            _v_step++;
            _v_step %= _cap;

            pthread_mutex_unlock(&_v_mtx);

            sem_post(&_blank_sem);//V
        }
};

#endif

```

`test.cc`

```cpp
#include "RingQueue.hpp"
#include <pthread.h>
#include <time.h>
#include <unistd.h>
#include "Task.hpp"

void* consumer(void* args)
{
     RingQueue<Task>* rq = (RingQueue<Task>*)args;
     while(true){
         Task t;
         rq->Pop(&t);
        //  std::cout << "消费数据是: " <<t.Show() << t() << "我是: " << pthread_self() << std::endl;
        t();  //比较耗时
         sleep(1);
     }
}

void* producter(void* args)
{
     RingQueue<Task>* rq = (RingQueue<Task>*)args;
     const std::string ops = "+-*/%";
     while(true){
         int x = rand()%20 + 1;
         int y = rand()%10 + 1;
         char op = ops[rand()%ops.size()];
         Task t(x, y, op);

         std::cout << "生产数据是:  " << t.Show() << "我是: " << pthread_self()<< std::endl;
         rq->Push(t);
        // sleep(1);
     }
}

int main()
{
    // 如果我们向改成多生产者，多消费者模型，该怎么改写
    srand((long long)time(nullptr));
    RingQueue<Task>* rq = new RingQueue<Task>();

    pthread_t c0,c1,c2,c3,p0,p1,p2;

    pthread_create(&c0, nullptr, consumer, (void*)rq);
    pthread_create(&c1, nullptr, consumer, (void*)rq);
    pthread_create(&c2, nullptr, consumer, (void*)rq);
    pthread_create(&c3, nullptr, consumer, (void*)rq);
    pthread_create(&p0, nullptr, producter, (void*)rq);
    pthread_create(&p1, nullptr, producter, (void*)rq);
    pthread_create(&p2, nullptr, producter, (void*)rq);

    pthread_join(c0, nullptr);
    pthread_join(c1, nullptr);
    pthread_join(c2, nullptr);
    pthread_join(c3, nullptr);
    pthread_join(p0, nullptr);
    pthread_join(p1, nullptr);
    pthread_join(p2, nullptr);

    return 0;
}

```

`Task.hpp`

```cpp
#ifndef __TASK_HPP__
#define __TASK_HPP__

#include <iostream>

class Task
{
    private:
        int _x;
        int _y;
        int _op;
    public:
        Task()
        {}

        Task(int x, int y, int op)
            :_x(x)
             ,_y(y)
             ,_op(op)
        {}

        std::string Show()
        {
            std::string message = std::to_string(_x);
            message += _op;
            message += std::to_string(_y);
            message += "=?";
            return message;
        }

        int Run()
        {
            int res = 0;
            switch(_op)
            {
                case '+':
                    res = _x + _y;
                    break;
                case '-':
                    res = _x - _y;
                    break;
                case '*':
                    res = _x * _y;
                    break;
                case '/':
                    res = _x / _y;
                    break;
                case '%':
                    res = _x % _y;
                    break;
                default:
                    std::cout << "bug???" << std::endl;
                    break;
            }

            std::cout << "当前任务正在被：" << pthread_self() << "处理："\
                << _x << _op << _y << "=" << res << std::endl;

            return res;
        }

        int operator()()
        {
            return Run();
        }

        ~Task()
        {}
};

#endif

```

