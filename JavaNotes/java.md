[TOC]

# Java概述

## 什么是Java？

Java是一门[面向对象](https://baike.baidu.com/item/面向对象)的编程语言，不仅吸收了[C++](https://baike.baidu.com/item/C%2B%2B)语言的各种优点，还摒弃了C++里难以理解的多继承、[指针](https://baike.baidu.com/item/指针/2878304)等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。

## Java的特点

Java具有简单性、面向对象、[分布式](https://baike.baidu.com/item/分布式/19276232)、[健壮性](https://baike.baidu.com/item/健壮性/4430133)、[安全性](https://baike.baidu.com/item/安全性/7664678)、平台独立与可移植性、[多线程](https://baike.baidu.com/item/多线程/1190404)、动态性等特点。

1. 简单性

   ​	Java看起来设计得很像[C++](https://baike.baidu.com/item/C%2B%2B)，但是为了使语言小和容易熟悉，设计者们把C++语言中许多可用的特征去掉了，这些特征是一般程序员很少使用的。例如，Java不支持[goto语句](https://baike.baidu.com/item/goto语句/7603004)，代之以提供[break](https://baike.baidu.com/item/break/405784)和[continue](https://baike.baidu.com/item/continue/3009735)语句以及异常处理。Java还剔除了C++的操作符过载*（**[overload](https://baike.baidu.com/item/overload/5090058)**）*和多继承特征，并且不使用主文件，免去了预处理程序。因为Java没有结构，数组和串都是对象，所以不需要指针。Java能够自动处理对象的引用和间接引用，实现自动的无用单元收集，使用户不必为存储管理问题烦恼，能更多的时间和精力花在研发上。

2. 面向对象

   ​	Java是一个面向对象的语言。对程序员来说，这意味着要注意其中的数据和操纵数据的方法*（method）*，而不是严格地用过程来思考。在一个面向对象的系统中，类*（**[class](https://baike.baidu.com/item/class/12502737)**）*是数据和操作数据的方法的集合。数据和方法一起描述对象*（object）*的状态和行为。每一对象是其状态和行为的封装。类是按一定体系和层次安排的，使得子类可以从超类继承行为。在这个类层次体系中有一个根类，它是具有一般行为的类。Java程序是用类来组织的。

3. 编译和解释性

   ​	Java编译程序生成字节码*（byte-code）*，而不是通常的机器码。Java字节码提供对体系结构中性的目标文件格式，代码设计成可有效地传送程序到多个平台。Java程序可以在任何实现了Java解释程序和运行系统*（run-time system）*的系统上运行。

   ​	在一个解释性的环境中，程序开发的标准“链接”阶段大大消失了。如果说Java还有一个链接阶段，它只是把新类装进环境的过程，它是增量式的、[轻量级](https://baike.baidu.com/item/轻量级/10002835)的过程。因此，Java支持快速原型和容易试验，它将导致快速程序开发。这是一个与传统的、耗时的“编译、链接和测试”形成鲜明对比的精巧的开发过程。
   
5. 分布性

  ​	Java设计成支持在网络上应用，它是分布式语言。Java既支持各种层次的网络连接，又以Socket类支持可靠的流*（**[stream](https://baike.baidu.com/item/stream)**）*网络连接，所以用户可以产生分布式的客户机和服务器。

5. 稳健性

   ​	Java原来是用作编写消费类家用电子产品软件的语言，所以它是被设计成写高可靠和稳健软件的。Java消除了某些编程错误，使得用它写可靠软件相当容易。

   ​	Java是一个强类型语言，它允许扩展编译时检查潜在类型不匹配问题的功能。Java要求显式的方法声明，它不支持C风格的[隐式声明](https://baike.baidu.com/item/隐式声明)。这些严格的要求保证编译程序能捕捉调用错误，这就导致更可靠的程序。

   ​	可靠性方面最重要的增强之一是Java的存储模型。Java不支持指针，它消除重写存储和[讹误](https://baike.baidu.com/item/讹误)数据的可能性。类似地，Java自动的“无用单元收集”预防存储漏泄和其它有关动态存储分配和解除分配的有害错误。Java解释程序也执行许多运行时的检查，诸如验证所有数组和串访问是否在界限之内。

6. 安全性

   ​	Java的存储分配模型是它防御[恶意代码](https://baike.baidu.com/item/恶意代码)的主要方法之一。Java没有指针，所以程序员不能得到隐蔽起来的内幕和伪造指针去指向[存储器](https://baike.baidu.com/item/存储器)。更重要的是，Java编译程序不处理存储安排决策，所以程序员不能通过查看[声明](https://baike.baidu.com/item/声明/13130358)去猜测类的实际存储安排。编译的Java代码中的存储引用在运行时由Java解释程序决定实际存储地址。

   ​	Java运行系统使用字节码验证过程来保证装载到网络上的代码不违背任何Java语言限制。这个安全机制部分包括类如何从网上装载。例如，装载的类是放在分开的名字空间而不是局部类，预防恶意的小应用程序用它自己的版本来代替标准Java类。

7. 高性能

   ​	Java是一种先编译后解释的语言，所以它不如全编译性语言快。但是有些情况下性能是很要紧的，为了支持这些情况，Java设计者制作了“及时”编译程序，它能在运行时把Java字节码翻译成特定[CPU](https://baike.baidu.com/item/CPU)*（中央处理器）*的机器代码，也就是实现全编译了。

   ​	Java字节码格式设计时考虑到这些“及时”编译程序的需要，所以生成机器代码的过程相当简单，它能产生相当好的代码。

8. 可移植性

   ​	Java使得语言声明不依赖于实现的方面。例如，Java显式说明每个基本数据类型的大小和它的运算行为*（这些数据类型由Java语法描述）*。

9. 多线程性

   ​	Java是多线程语言，它提供支持多线程的执行*（也称为轻便过程）*，能处理不同任务，使具有线索的程序设计很容易。Java的lang包提供一个[Thread](https://baike.baidu.com/item/Thread/5156974)类，它支持开始线索、运行线索、停止线索和检查线索状态的方法。

   ​	Java的线索支持也包括一组同步原语。这些原语是基于监督程序和条件变量风范，由C.A.R.Haore开发的广泛使用的同步化方案。用关键词[synchronized](https://baike.baidu.com/item/synchronized)，程序员可以说明某些方法在一个类中不能并发地运行。这些方法在监督程序控制之下，确保变量维持在一个一致的状态。

10. 动态性

   ​	Java语言设计成适应于变化的环境，它是一个动态的语言。例如，Java中的类是根据需要载入的，甚至有些是通过网络获取的。

## Java能做什么？

Java可以编写[桌面应用程序](https://baike.baidu.com/item/桌面应用程序/2331979)、Web应用程序、[分布式系统](https://baike.baidu.com/item/分布式系统/4905336)和[嵌入式系统](https://baike.baidu.com/item/嵌入式系统/186978)应用程序等。

## Java发展史

20世纪90年代，硬件领域出现了单片式计算机系统，这种价格低廉的系统一出现就立即引起了自动控制领域人员的注意，因为使用它可以大幅度提升消费类电子产品*（如电视机顶盒、面包烤箱、移动电话等）*的[智能化](https://baike.baidu.com/item/智能化)程度。Sun公司为了抢占市场先机，在1991年成立了一个称为Green的项目小组，[帕特里克](https://baike.baidu.com/item/帕特里克/4831889)、[詹姆斯·高斯林](https://baike.baidu.com/item/詹姆斯·高斯林)、麦克·舍林丹和其他几个工程师一起组成的工作小组在[加利福尼亚](https://baike.baidu.com/item/加利福尼亚)州[门洛帕克](https://baike.baidu.com/item/门洛帕克)市沙丘路的一个小工作室里面研究开发新技术，专攻计算机在家电产品上的嵌入式应用。

由于[C++](https://baike.baidu.com/item/C%2B%2B)所具有的优势，该项目组的研究人员首先考虑采用C++来编写程序。但对于[硬件](https://baike.baidu.com/item/硬件)资源极其匮乏的单片式系统来说，C++程序过于复杂和庞大。另外由于消费电子产品所采用的嵌入式处理器芯片的种类繁杂，如何让编写的程序[跨平台](https://baike.baidu.com/item/跨平台)运行也是个难题。为了解决困难，他们首先着眼于语言的开发，假设了一种结构简单、符合嵌入式应用需要的硬件平台体系结构并为其制定了相应的规范，其中就定义了这种硬件平台的[二进制](https://baike.baidu.com/item/二进制)机器码指令系统*（即后来成为“**[字节码](https://baike.baidu.com/item/字节码)**”的指令系统）*，以待语言开发成功后，能有[半导体芯片](https://baike.baidu.com/item/半导体芯片)生产商开发和生产这种硬件平台。对于新语言的设计，Sun公司研发人员并没有开发一种全新的语言，而是根据嵌入式软件的要求，对C++进行了改造，去除了留在C++的一些不太实用及影响安全的成分，并结合嵌入式系统的实时性要求，开发了一种称为[Oak](https://baike.baidu.com/item/Oak)的[面向对象语言](https://baike.baidu.com/item/面向对象语言)。

由于在开发Oak语言时，尚且不存在运行字节码的硬件平台，所以为了在开发时可以对这种语言进行实验研究，他们就在已有的硬件和软件平台基础上，按照自己所指定的规范，用软件建设了一个运行平台，整个系统除了比C++更加简单之外，没有什么大的区别。1992年的夏天，当Oak语言开发成功后，研究者们向硬件生产商进行演示了Green操作系统、Oak的程序设计语言、类库和其硬件，以说服他们使用Oak语言生产硬件芯片，但是，硬件生产商并未对此产生极大的热情。因为他们认为，在所有人对Oak语言还一无所知的情况下，就生产硬件产品的风险实在太大了，所以Oak语言也就因为缺乏硬件的支持而无法进入市场，从而被搁置了下来。

1994年6、7月间，在经历了一场历时三天的讨论之后，团队决定再一次改变了努力的目标，这次他们决定将该技术应用于[万维网](https://baike.baidu.com/item/万维网)。他们认为随着[Mosaic](https://baike.baidu.com/item/Mosaic)浏览器的到来，[因特网](https://baike.baidu.com/item/因特网)正在向同样的高度互动的[远景](https://baike.baidu.com/item/远景)演变，而这一远景正是他们在有线电视网中看到的。作为原型，帕特里克·诺顿写了一个小型万维网浏览器WebRunner。 [8] 

1995年，互联网的蓬勃发展给了Oak机会。业界为了使死板、单调的静态网页能够“灵活”起来，急需一种软件技术来开发一种程序，这种程序可以通过网络传播并且能够跨平台运行。于是，世界各大[IT](https://baike.baidu.com/item/IT/16684878)企业为此纷纷投入了大量的人力、物力和财力。这个时候，Sun公司想起了那个被搁置起来很久的Oak，并且重新审视了那个用软件编写的试验平台，由于它是按照嵌入式系统硬件平台体系结构进行编写的，所以非常小，特别适用于网络上的传输系统，而Oak也是一种精简的语言，程序非常小，适合在网络上传输。Sun公司首先推出了可以嵌入网页并且可以随同网页在网络上传输的[Applet](https://baike.baidu.com/item/Applet)*（Applet是一种将小程序嵌入到网页中进行执行的技术）*，并将Oak更名为Java*（在申请注册商标时，发现Oak已经被人使用了，再想了一系列名字之后，最终，使用了提议者在喝一杯Java咖啡时无意提到的Java词语）*。5月23日，Sun公司在Sun world会议上正式发布Java和HotJava浏览器。[IBM](https://baike.baidu.com/item/IBM/9190)、[Apple](https://baike.baidu.com/item/Apple/3860362)、DEC、[Adobe](https://baike.baidu.com/item/Adobe)、HP、[Oracle](https://baike.baidu.com/item/Oracle)、Netscap**e**和[微软](https://baike.baidu.com/item/微软)等各大公司都纷纷停止了自己的相关开发项目，竞相购买了Java使用许可证，并为自己的产品开发了相应的Java平台。 [9-10] 

1996年1月，Sun公司发布了Java的第一个开发工具包*（JDK 1.0）*，这是Java发展历程中的重要里程碑，标志着Java成为一种独立的开发工具。9月，约8.3万个网页应用了Java技术来制作。10月，Sun公司发布了Java平台的第一个即时*（JIT）*编译器。

1997年2月，JDK 1.1面世，在随后的3周时间里，达到了22万次的下载量。4月2日，Java One会议召开，参会者逾一万人，创当时全球同类会议规模之纪录。9月，Java Developer Connection社区成员超过10万。

1998年12月8日，第二代Java平台的企业版J2EE发布。1999年6月，Sun公司发布了第二代Java平台（简称为Java2）的3个版本：[J2ME](https://baike.baidu.com/item/J2ME)（Java2 Micro Edition，Java2平台的微型版），应用于移动、无线及有限资源的环境；[J2SE](https://baike.baidu.com/item/J2SE)（Java 2 Standard Edition，Java 2平台的标准版），应用于桌面环境；[J2EE](https://baike.baidu.com/item/J2EE)（Java 2Enterprise Edition，Java 2平台的企业版），应用于基于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个里程碑，标志着Java的应用开始普及。

1999年4月27日，HotSpot虚拟机发布。[HotSpot](https://baike.baidu.com/item/HotSpot)虚拟机发布时是作为JDK 1.2的附加程序提供的，后来它成为了JDK 1.3及之后所有版本的Sun JDK的默认虚拟机 。

2000年5月，JDK1.3、JDK1.4和J2SE1.3相继发布，几周后其获得了[Apple](https://baike.baidu.com/item/Apple/3860362)公司Mac OS X的工业标准的支持。2001年9月24日，J2EE1.3发布。2002年2月26日，J2SE1.4发布。自此Java的计算能力有了大幅提升，与J2SE1.3相比，其多了近62%的类和接口。在这些新特性当中，还提供了广泛的[XML](https://baike.baidu.com/item/XML)支持、安全套接字*（Socket）*支持*（通过SSL与TLS协议）*、全新的I/OAPI、正则表达式、日志与断言。2004年9月30日，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE 1.5更名为Java SE 5.0*（内部版本号1.5.0）*，代号为“Tiger”，Tiger包含了从1996年发布1.0版本以来的最重大的更新，其中包括泛型支持、基本类型的自动装箱、改进的循环、枚举类型、格式化I/O及可变参数。

2005年6月，在Java One大会上，Sun公司发布了Java SE 6。此时，Java的各种版本已经更名，已取消其中的数字2，如J2EE更名为[JavaEE](https://baike.baidu.com/item/JavaEE)，J2SE更名为JavaSE，J2ME更名为[JavaME](https://baike.baidu.com/item/JavaME)。

2006年11月13日，Java技术的发明者Sun公司宣布，将Java技术作为免费软件对外发布。Sun公司正式发布的有关Java平台标准版的第一批源代码，以及Java迷你版的可执行源代码。从2007年3月起，全世界所有的开发人员均可对Java源代码进行修改。

2009年，甲骨文公司宣布收购Sun。

2010年，Java编程语言的共同创始人之一詹姆斯·高斯林从Oracle公司辞职。2011年，甲骨文公司举行了全球性的活动，以庆祝Java7的推出，随后Java7正式发布。

2014年，甲骨文公司发布了Java8正式版。

2017 年 9 月 22 日，Java 9正式发布，带来了很多新特性，其中最主要的变化是已经实现的模块化系统。

# 变量与常量

## 变量

变量就是可以更改内容的箱子，变量一般也叫左值。

### 变量的几种分类

1. 普通成员变量
2. 静态成员变量
3. 局部变量

## 常量

常量就是一个封闭的箱子里面存放的东西无法再更改，常量通常也叫右值。

### 常量的几种分类

1. 字面常量
2. final修饰的常量



# 类型

Java中的类型是强类型，类型之间不能直接赋值，同时定义一个变量时必须初始化。

Java中当一个值超过了该类型的最大表示范围那么会报错。

## 字节类型变量

Java中存在一个字节的类型，不过该类型是整型的一种。

```java
byte a = 10;
```

## 短整型变量

Java中的短整型为两个字节。

```java
short a = 10;
```

## 整型变量

Java中的整型占四个字节

```java
int a = 10;
```

## 长整型变量

Java中的长整型占8个字节

```java
long a = 10;
```

## 单精度浮点型变量

Java中单精度浮点型占4个字节

```java
float a = 1.4f;//注意字面小数默认是双精度浮点型
```



## 双精度浮点型变量

Java中双精度浮点型占8个字节。

```java
double a = 3.5;
```

## 字符类型变量

Java中字符型占2个字节。

```java
char ch = '我';//可以存放一个中文
```

## 布尔型变量

Java中布尔型变量占几个字节没有规定，但是布尔类型只能表示两个值`true`和`false`。

```java
boolean a = true;
```

**注意：Java中只能低字节类型能给高字节类型，如果想让高字节类型给低字节类型需要用强制类型转换，不过强制类型转换存在风险。**

# 方法

## 什么是方法？

Java当中的方法其实就是C语言中的函数，只是叫法不同本质是一样的。

## 方法的定义

**方法定义：**`public` `staic` 返回值类型 方法名(参数列表) {方法体};

**实列：**

```java
public static int add(int a, int b) {
    return a + b;
}
```

### 值传递和引用传递

#### 值传递

Java中没有地址的概念所以任何在栈上开辟的对象在传参时都只会作为值传递，值传递是一种拷贝形参的改变不会对实参有任何影响。

#### 引用传递

Java中的引用传递形参是可以影响到实参的因为引用传递本质就是传递实参本身而不是拷贝。

Java中什么情况下才是引用传递呢？当一个对象是从堆上开辟的空间做为参数传递时就是引用传递。

## 方法重载

有时候有些函数功能一样但是针对不同类型的类型不一样，我们又想用同一个方法名这时我们可以用方法重载。

### 方法重载规则

1. 方法名相同
2. 类型或参数个数不同

**实列：**

```java
public static int add(int a, int b) {
    return a + b;
}

public static double add(double a, double) {
    return a + b;
}
```

## 值传递

Java中的值传递其实是一种“拷贝”，它会把实参传递的数据拷贝一份并压进调用方法的战帧中，而这时的参数不会影响到实参同时这个栈帧被销毁时该参数也会随之消亡。

当实参传递的数据不是堆上开辟的空间生命周期都会受到影响。

## 引用传递

引用传递传递的是数据地址，虽然Java中没有地址的概念但是引用变量定义是底层是存放数据地址来保证索引到数据同时保存在堆上。

引用传递也不列外在做为实参传递给方法形参时也是一种拷贝，不过拷贝的数据是一段地址所以形参对该地址存放的数据进行修改都会影响到实参，因为该地址存的数据是在堆上开辟的空间。

## 递归

递归是通过自己调用自己来完成某项任务，再递归调用的途中，任务会从大变小直到小到不能再分配才执行任务，而这时执行的任务量会变的无比小，虽然任务量变小了但是在栈上的空间消耗也变大，因为有很多没用的重复指令一直被递归分解。

这也是为什么递归处理大型计算任务时会变的巨慢无比，迭代能一秒计算出来的数据递归可能要花上一个小时甚至更久……

能用递归完成的任务绝大部分都能迭代完成，所以一般是能用迭代绝对不用递归。

### 递归的优点

+ 递归代码简单
+ 代码量少

### 递归的缺点 

+ 栈的空间消耗大
+ 冗余数据过多
+ 计算大型任务效率极低



# 数组

Java中的数组就是一段连续的空间存放相同类型的值，Java中数组开辟的空间是在堆上开辟而不是栈上，所以Java中的数组变量也叫引用变量。

## 数组的定义

**定义语法：** 类型[] 变量名；

**列子：**

```java
int[] arr = { 1, 2, 3 };
```

## 数组的初始化方式

**Java中数组初始化有两种方式：**

1. `new` 类型；
2. { 数据 };

**例子：**

```java
int[] arr1 = { 1, 2, 3, 4 };
int[] arr2 = new int[1];
```

## 多维数组

### 二维数组定义

Java中的二维数组和C语言大同小异，唯一的区别是`{}`内没初始化数据时，Java不能省略第一个`[]`的数据。

**例子：**

```java
int[3][] arr1 = { {12}, {3}, {4} };
int[][] arr2 = { {1}, {2}, {3} };
```

### 不规则数组

Java中数组的如果没指定最后一个`[]`内的数据时，在赋值时每个`int[]`类型都可以是不同。

**列子：**

```java
int[3][] arr = { {1, 2, 3, 4, 5}, {5}, {3, 4, 5}};
```

# 类和对象

## 什么是面向对象？

面向对象其实就是只关注类和方法的形式，不会关注方法的实现和类里面有什么，只关注类和方法的交互。

**例子：**比如写一个送快递软件，在这里面我们可以把商家、快递和客户员当成一个类，我们只关注客户下单的行为、商家发货的行为和快递员运送的行为，只会关注它们三个之间的交互不会看具体如何送、如何下单和如何发货的过程，这就是面向对象快递员是一个对象、客户还有商家也是一个对象。

## 什么是类？

类是一种统称叫法，比如人我们知道有很多个不同的人但是他们本身都是人这个类，所以类是一种类型或复杂的事物等等的统称。

具体的一个人就是通过一个类实列化出来的对象，而这个实列化出来的对象就是一个具体的人。



## 创建类的方法

我们可以通过`class`关键字来创建一个类。

**使用方法：** `class` 类名 {类成员};

```java
class Date {
    //类成员变量
    private int _day;
    private int _month;
    private int _year;
    
    //类成员方法
    public int GetDay() {
        return _day;
    }
}
```

## 静态成员

### 静态成员方法

静态成员方法通过`static`修饰来定义，静态方法没有`this`且只能调用静态方法。

静态方法无法在类里面创建静态变量，我们可以发现`main`函数本身也是一个静态方法，其实`main`函数可以不是静态的方法，但是Java的JVM中规定`main`方法必须定义为静态的否则无法调用。



### 静态成员变量

静态成员变量属于类不属于某个方法同时不过实列化多少个对象都只有一个静态成员变量，每个对象能看到的静态成员都是同一个。



## 普通成员

### 普通成员方法

普通成员方法能调用静态成员方法，同时也能定义静态变量，因为普通成员方法在调用静态方法时属于一种“权限的缩小”。

### 普通成员变量

普通成员变量属于具体的某个对象，当一个对象实列化出来时都有一个属于自己的普通成员变量，每个对象的普通成员变量只能看到自己看不到其它对象的同时不能共用。

## 默认成员方法

### 默认构造方法

默认构造方法的定义是：

1. 无返回值
2. 方法名和类名相同

默认构造方法有多种，可以通过方法重载来实现不同效果的构造方法。

默认构造方法即使没写编译器也会自动生成一个不过编译器自动生成的默认构造方法什么都不会做，默认构造方法一般使用来初始化成员变量的。

## 匿名对象

有时候我们想用该类的某个方法用一次就不用了，如果直接实列化一个对象来使用，这样就显得有点麻烦了所以Java当中支持一个叫匿名对象的语法，匿名对象就是来满足此类需求的，匿名对象的生命周期是在当前行一但执行完当前行就会自动销毁。

**匿名对象的定义：** `new` 类名();

**例子：**

```java
class Date {
    //类成员变量
    private int _day;
    private int _month;
    private int _year;
    
    //类成员方法
    public int GetDay() {
        return _day;
    }
}

public static void main(String[] argv) {
    new Date().GetDay();//匿名对象
}
```

## 封装

封装就是指开放公有的方法，一些数据不开放出来外面的人看不到就不会对数据造成安全隐患。

C语言中没有封装一个结构体的数据可以在任意地方被更改，这就使得数据很不安全任意出错。

而Java中提供了`public`和`private`这两个关键字来保证数据的安全，在Java当中类中的成员变量都不会给外部随意访问的所以绝大部分的成员变量都会被`private`修饰，而`private`的作用是私有。

当一个成员变量是一个私有成员那么对外部是不可见的，子要外部不可见就不可以随意修改该成员变量的值，从而保证数据的安全。

`public`是公有的意思，当一个成员变量或成员方法被此关键字修饰类外就可以调用这个方法或成员。

一般方法才会定义成公有的，这样Java就完成了封装，你想访问一些数据得通过公有的方法才能访问这样就可以保证数据的安全的同时也可以达到访问和修改的目的。

## 代码块

### 静态代码块

静态代码块是类里面的一种代码块，它每次都会执行一次且是在构造函数之前，从此再也不会执行即使没有试实例化对象也会执行，只要你使用了类里面的任意一种东西就会自动执行。

#### 静态代码块的定义

```java
class Date{
    static {
        System.out.println("静态代码块);
    }
}
```

### 实列代码块

实列化代码块和静态代码块类似不过有静态代码块存在的时候会优先调用静态的代码块。

顺序为：静态代码块->实力代码块->构造方法

实列代码块是当有一个对象实列化之后才会执行，所以有多少个实列化对象就会有执行多次实列代码块的内容。

#### 实列代码块的定义

```java
class Date {
    {
        System.out.println("s")
    }
}
```

# 包

## 什么是包？

包是一种组织类的一种形式，最主要的是防止类名冲突，所以一个类会定义到一个包里当想用这个包里的类的时候就要先导包来引导编译器找到这个类。

Java中的包类似C++里面的`#include`但是有一点区别，Java导包不能导入具体的包，只能导入具体包里面的具体的类。

如果使用“通配符”来导入一个包里面的所有内容，那么Java不会全部导入进来，而是在程序运行的时候需要那个包的类就会自动去找，而不是全部正进来这样大大提高了空间利用率。

如果是C++那么包一个头文件会把所有方法都拷贝进主方法，不管你会不会用得到。

## 导入包中的类

Java中导入包的语法：`import` java.包名.类名

**例子：**

```java
import java.util.Date
```

## package和import的区别

`package` 类似C++里面的命名空间域给源文件标记一个名字，这样就可以防止名字冲突。

`import`类似C++里面的包含头文件，用来告诉编译器哪里可以找到这个类。

## 静态导入

使用`import static`可以导入包中的静态方法和字段，不过这种导入方式用的场景非常少，我们了解即可。

**例子：**

```java
import static java.lan.Math.*;

public class Test {
    public void main(String[] args) {
        //静态导入包，可以神略类名来调用方法
        double ret = sqrt(8);
    }
}
```

## 将类放到包中

## 基本规则

1. 在文件的第一行加`package`关键字来指定该代码在那个包中。
2. 包名需要尽量指定成唯一的名字，通常会用公司的域名颠倒形式（`com.ls.demo`)
3. 包名和代码的路径要匹配（如：创建`com.ls.demo`的包，那么会存在一个对应的路径`com/ls/demo`来存储代码。
4. 如果一个类中没有`package`来指定是那个包中的类，那么该类会放到默认包中。

## 具体操作步骤

**创建包：**

![image-20220602162036287](https://cdn.jsdelivr.net/gh/ls02/Image/img/202211122313826.png)

**创建包名：**

![image-20220602162136718](https://cdn.jsdelivr.net/gh/ls02/Image/img/202211212350204.png)

回车表示输入完成，当回车之后会生成一个包。

![image-20220602162228395](https://cdn.jsdelivr.net/gh/ls02/Image/img/202211172141532.png)

接着我们在新建的包里面创建一个类。

![image-20220602162348188](https://cdn.jsdelivr.net/gh/ls02/Image/img/202211142129315.png)

此时编译器就会在磁盘上创建一个路径，我们跟着路径走到低回发现有一个刚刚我们创建的类。

![image-20220602162559260](https://cdn.jsdelivr.net/gh/ls02/Image/img/202211161955960.png)

同时我们用`idea`打开这个类会发现`idea`会自动帮我们加上`package`指定包。

![image-20220602162728589](https://cdn.jsdelivr.net/gh/ls02/Image/img/202211152210833.png)

### 包的访问控制权限

`public`和`private`也能对包进行作用，如：包中的一个成员有`priavte`权限只能在类里面使用，如果是`public`则可以在包外也能调用，如果什么都不加那么默认只能在包里面使用该成员。

### 常见的系统包

1. `java.lang`（系统常用基础类，此包从JDK1.1之后就会自动导入）
2. `java.lang.reflect`（Java反射包）
3. `java.net`（进行网络编程开发包）
4. `java.sql`（数据库开发的支持包）
5. `java.util`（java提供的工具程序包，（集合类等等）很重要）
6. `java.io`（I/O编程开发包）



# 继承

继承本质是为了提高代码的复用性，减少冗余代码来达到高效开发的目的。

继承除了`private`修饰的成员，其它成员都会被子类继承。

**举个例子：** 动物，动物有很多种而动物都有一个特性有性别、年龄和行为等等……如果我们一个动物定义一个类的会，那么里面会有很多重复出现的成员，这时我们可以不可以用一个类概括所有动物而且这个类都有所有动物都会有的成员，于是就有了这样的设计先创建一个动物类，再用一个具体的动物类来继承这个动物这样提高了代码的复用性同时也减少了代码量。

## 继承语法

**继承语法：** `class 子类 extends 父类` {}

+ Java中不存在多继承只有单继承。
+ 使用`extends`来指定继承的父类
+ 子类可以使用父类里面的所有`public`的字段和方法。
+ 父类中的`private`修饰的字段和方法，对于继承的子类是不可见的（当然也可以理解成没有继承下来也对）。
+ 子类的实列中也包含了父类的实列，可以使用`super`关键字得到父类实列的引用。

## this和super的区别

`this`的作用是在类里面是该类的一个实列引用，谁是实列，那么`this`就是那个实例的引用。

`super`的作用是显示调用父类的方法或成员，有时候子类和父类有一个相同名字的方法或成员变量，编译器调用自己当前类的，想调用父类的就用`supear`显示调用。

## protected关键字

有时候我们对成员的权限控制的时候有一个需求，我们想让子类能调用该方法同时不然类外的对象调用，这个时候我们用`public`和`private`都无法满足。

这时`protected`就诞生了，`protected`主要是用来解决继承中的问题，它可以被子类访问但不能被类外的对象访问。

+ 对于类的调用者来说`protected`修饰的字段和方法是不能访问的。
+ 对于类的子类和同一个包的其它类来说，`protected`修饰的字段和方法是可以访问的。

**总结：Java中对于字段和方法共有四种访问权限**

+ `private:`类内部能访问，类外部不能访问。
+ 默认（包访问劝降）：类内部能访问，同一个中的类也能访问，其它类不能访问。
+ `protected：`类内部能访问，子类和同一个包中的类也可以访问，其它类不能访问。
+ `public：`类内部和类的调用者都能访问。

## final关键字

`final`不仅可以修饰一个变量或字段，还能修饰类。（修饰字段或变量的时候表示该变量是常量）

当也给类被`final`修饰的时候是无法继承的。

**例子：**

```java
final class A {//表示无法被继承
    
}

class B extends A {//如果强行继承编译器会报错
    
}
```

# 多态

## 什么是多态？

多态从字面上来理解就是多种形态，但是在Java里面是不同对象调用不同方法产生不同结果，这就是多态。

## 静态多态

Java中的静态多态就是重载方法，重载方法是多态的一种形式，不过是静态的在编译前就确定好的了。

## 动态多态

动态多态是通过重写来完成动态绑定来实现的多态，动态的多态是在编译运行时来确定的所以叫动态的多态。

### 重写

当子类的方法名、参数列表和返回值相同时就会构成重写，子类的方法会重写父类。

**重写的条件：**

1. 方法名相同
2. 参数列表相同

#### 协变

协变其实是方法重写的另一种形式，协变和重写不同的是返回值和父类不同这时也构成重写不过这种特殊的重写叫做协变。



## 向上转型

当一个父类对象引用子类，那么这种行为就是向上转型，当调用重写方法时会调用的是子类的因为父类的方法会被子类重写。

## 向下转型

向下转型是子类引用对象引用父类，但是不能直接引用我们需要通过强制转换来完成。

但是通过强转来完成的向下转型有安全风险，所以我们推荐用一下方法来完成：

```java
Animal animal = new Cat("小猫");
if (animal instanceof Bird) {
	Bird bird = (Bird)animal;
	bird.fly();
}
```

## 抽象类

**抽象类语法：** `abstract class 类名` {}

```java
abstract class Shape {
	abstract public void draw();
}
```

抽象类是不能实列化对象的，因为抽象类是专门为了继承而诞生的。

**注意：**

1. 抽象类无法实列化
2. 抽象方法不能是`private`
3. 抽象类可以包含其它的非抽象类方法和字段，这个非抽象方法和普通方法规则都是一样的，可以被重写也可以被子类直接调用。

### 抽象类的作用

抽象类存在的意义就是为了被继承。

抽象类本身不能实列化如果想要使用必须创建该类的子类，然后让子类重写抽象类的方法。



### 抽象类总结

1. 包含抽象方法的类，叫做抽象类
2. 抽象方法是一个没有具体实现的方法被`abstract`修饰
3. 抽象类不能被实列化，抽象类只能被继承
4. 抽象类中可以包含和普通类一样的成员和方法
5. 一个普通类继承了一个抽象类，那么这个普通类当中，需要重写抽象类的所有抽象方法。
6. 一个抽象类A，如果继承了一个抽象类B那么这个抽象类A，可以不实现抽象父类B的抽象方法。
7. 结合第六点，当A类再次被一个普通类继承后，那么A和B这两个抽象类当中的抽象方法，必须被重写。
8. 抽象类最大的作用就是被继承。
9. 抽象类不能被`final`修饰，抽象方法也不可以被`final`修饰。



## 接口

接口是抽象类的更进一步抽象类还可以包含非抽象方法和字段，而接口中包含的方法都是抽象方法，字段只能包含静态常量。

### 语法规则

```java
interface IShape {
void draw();
}
class Cycle implements IShape {
@Override
public void draw() {
System.out.println("○");
}
}
public class Test {
public static void main(String[] args) {
IShape shape = new Rect();
shape.draw();
}
}
```

+ 使用`interface`定义一个接口
+ 接口中的方法一定是`public`，因此可以省略`public`
+ 接口中的方法一定是抽象方法，因此可以省略`abstract`
+ `Cycle`使用`implements`继承接口，此时表达的含义不再是“扩展“而是”实现“
+ 在调用的时候同样可以创建一个接口的引用，对应到一个子类的实例。
+ 接口不能被单独实列化

#### 扩展与实现

+ 扩展

  当前已经又一定的功能了，进一步扩充功能

+ 实现

  当前啥也没有需要从头构造出来

接口中只能包含抽象方法，对于字段来说，接口中只能包含静态常量(`final static`）。

**注意：**

1. 我们创建接口的时候，接口命名一般以大写字母的`I`开头。
2. 接口的命名一般使用”形容词“词性的单词
3. 阿里编码规范中约定，接口中的方法和属性不要加任何修饰符，保持代码的简洁性。

![image-20220602204246164](https://cdn.jsdelivr.net/gh/ls02/Image/img/202211132200193.png)

### 实现多个接口

有的时候一个我们需要一个类同时继承多个父类，有些编程语言通过多继承完成，但是Java中没有多继承，一个类只能继承一个类。

但是可以同时实现多个接口，也能达到多继承的效果。

**例子：**

```java
class A extends B implements IA, IB, IC {
    //...
}
```

### 接口总结

1. 使用`interface`来修饰。
2. 接口当中的普通方法，不能有具体的实现，非要实现只能通过关键字`default`来修饰这个方法。
3. 接口当中可以有`static`的方法
4. 接口里面的所有的方法都是`public`的。
5. 抽象方法，默认是`public abstract`的。
6. 接口时不可以通过关键字`new`来实列化。
7. 类和接口之间的关系是通过`implements`实现。
8. 当一个类实现了一个接口就必须要重写接口当中的抽象方法。
9. 接口当中的成员变量，默认都是`public static final`修饰的。
10. 当一个类实现一个接口之后，重写这个方法的时候，这个方法前面必须加上`public`
11. 一个类通过关键字`extends`继承一个抽象类或者普通类，但是只能继承一个类。同时，也可以通过`implements`实现多个接口，接口之间使用都好隔开就好。

