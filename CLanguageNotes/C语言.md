[TOC]

# 什么是Ｃ语言？

# C语言简介

> C语言是一门[面向过程](https://baike.baidu.com/item/面向过程/9957246)的[计算机编程语言](https://baike.baidu.com/item/计算机编程语言/5581937)，与[C++](https://baike.baidu.com/item/C%2B%2B/99272)、C#、[Java](https://baike.baidu.com/item/Java/85979)等[面向对象](https://baike.baidu.com/item/面向对象/2262089)编程语言有所不同。C语言的设计目标是提供一种能以简易的方式[编译](https://baike.baidu.com/item/编译/1258343)、处理低级[存储器](https://baike.baidu.com/item/存储器/1583185)、仅产生少量的[机器码](https://baike.baidu.com/item/机器码/86125)以及不需要任何运行环境支持便能运行的编程语言。C语言描述问题比[汇编语言](https://baike.baidu.com/item/汇编语言/61826)迅速、工作量小、可读性好、易于[调试](https://baike.baidu.com/item/调试)、修改和移植，而[代码质量](https://baike.baidu.com/item/代码质量/8863758)与[汇编语言](https://baike.baidu.com/item/汇编语言/61826)相当。C语言一般只比汇编语言代码生成的[目标程序](https://baike.baidu.com/item/目标程序/8082041)效率低10%-20%。因此，C语言可以编写[系统软件](https://baike.baidu.com/item/系统软件/215962)。
>
> 当前阶段，在编程领域中，C语言的运用非常之多，它兼顾了[高级语言](https://baike.baidu.com/item/高级语言/299113)和汇编语言的优点，相较于其它编程语言具有较大优势。计算机系统设计以及应用程序编写是C语言应用的两大领域。同时，C语言的普适较强，在许多计算机操作系统中都能够得到适用，且效率显著。
>
> C语言拥有经过了漫长发展历史的完整的理论体系，在编程语言中具有举足轻重的地位。

## 发展史

> C语言诞生于美国的[贝尔实验室](https://baike.baidu.com/item/贝尔实验室/686816)，由[丹尼斯·里奇](https://baike.baidu.com/item/丹尼斯·里奇/7267171)（Dennis MacAlistair Ritchie）以[肯·汤普森](https://baike.baidu.com/item/肯·汤普森/50235682)（Kenneth Lane Thompson）设计的[B语言](https://baike.baidu.com/item/B语言/1845842)为基础发展而来，在它的主体设计完成后，汤普森和里奇用它完全重写了UNIX，且随着UNIX的发展，c语言也得到了不断的完善。为了利于C语言的全面推广，许多专家学者和硬件厂商联合组成了C语言标准委员会，并在之后的1989年，诞生了第一个完备的C标准，简称“[C89](https://baike.baidu.com/item/C89/22224985)”，也就是“[ANSI C](https://baike.baidu.com/item/ANSI C/7657277)”，截至2020年，最新的C语言标准为2018年6月发布的“C18”。
>
> C语言之所以命名为C，是因为C语言源自[Ken Thompson](https://baike.baidu.com/item/Ken Thompson)发明的[B语言](https://baike.baidu.com/item/B语言)，而[B语言](https://baike.baidu.com/item/B语言/1845842)则源自BCPL语言。
>
> 1967年，[剑桥大学](https://baike.baidu.com/item/剑桥大学)的Martin Richards对[CPL语言](https://baike.baidu.com/item/CPL语言/2507754)进行了简化，于是产生了[BCPL](https://baike.baidu.com/item/BCPL/10540583)（Basic Combined Programming Language）语言。
>
> 20世纪60年代，美国[AT&T](https://baike.baidu.com/item/AT%26T)公司[贝尔实验室](https://baike.baidu.com/item/贝尔实验室/686816)（AT&T Bell Laboratories）的研究员肯·汤普森（Kenneth Lane Thompson）闲来无事，手痒难耐，想玩一个他自己编的，模拟在太阳系航行的电子游戏——Space Travel。他背着老板，找到了台空闲的小型计算机——[PDP-7](https://baike.baidu.com/item/PDP-7)。但这台电脑没有操作系统，而游戏必须使用操作系统的一些功能，于是他着手为PDP-7开发操作系统。后来，这个操作系统被命名为——UNICS（Uniplexed Information and Computing Service）。
>
> 1969年，[美国贝尔实验室](https://baike.baidu.com/item/美国贝尔实验室/14738104)的Ken Thompson，以BCPL语言为基础，设计出很简单且很接近硬件的[B语言](https://baike.baidu.com/item/B语言/1845842)（取BCPL的首字母），并且用B语言写了初版[UNIX](https://baike.baidu.com/item/UNIX/219943)操作系统（叫UNICS）。
>
> 1971年，同样[酷爱](https://baike.baidu.com/item/酷爱/1371)Space Travel的丹尼斯·里奇为了能早点儿玩上游戏，加入了汤普森的开发项目，合作开发UNIX。他的主要工作是改造B语言，使其更成熟。
>
> 1972年，美国贝尔实验室的丹尼斯·里奇在B语言的基础上最终设计出了一种新的[语言](https://baike.baidu.com/item/语言/2291095)，他取了BCPL的第二个字母作为这种语言的名字，这就是C语言。
>
> 1973年初，C语言的主体完成。汤普森和里奇迫不及待地开始用它完全重写了[UNIX](https://baike.baidu.com/item/UNIX)。此时，编程的乐趣使他们已经完全忘记了那个“Space Travel”，一门心思地投入到了UNIX和C语言的开发中。随着UNIX的发展，C语言自身也在不断地完善。直到2020年，各种版本的UNIX内核和周边工具仍然使用C语言作为最主要的开发语言，其中还有不少继承汤普逊和里奇之手的代码。
>
> 在开发中，他们还考虑把[UNIX](https://baike.baidu.com/item/UNIX)移植到其他类型的计算机上使用。C语言强大的移植性（Portability）在此显现。机器语言和[汇编语言](https://baike.baidu.com/item/汇编语言/61826)都不具有移植性，为[x86](https://baike.baidu.com/item/x86)开发的程序，不可能在[Alpha](https://baike.baidu.com/item/Alpha/6892014)、[SPARC](https://baike.baidu.com/item/SPARC)和[ARM](https://baike.baidu.com/item/ARM/7518299)等机器上运行。而C语言程序则可以使用在任意架构的[处理器](https://baike.baidu.com/item/处理器)上，只要那种架构的处理器具有对应的C语言[编译器](https://baike.baidu.com/item/编译器)和库，然后将C源代码[编译](https://baike.baidu.com/item/编译)、[连接](https://baike.baidu.com/item/连接/8248019)成目标[二进制文件](https://baike.baidu.com/item/二进制文件)之后即可在哪种架构的处理器运行。
>
> 1977年，丹尼斯·里奇发表了不依赖于具体机器系统的C语言编译文本《可移植的C语言编译程序》。
>
> C语言继续发展，在1982年，很多有识之士和[美国国家标准协会](https://baike.baidu.com/item/美国国家标准协会/5709537)（[ANSI](https://baike.baidu.com/item/ANSI/10401940)）为了使C语言健康地发展下去，决定成立C标准委员会，建立C语言的标准。委员会由硬件厂商、编译器及其他软件工具生产商、软件设计师、顾问、学术界人士、C语言作者和应用程序员组成。1989年，ANSI发布了第一个完整的C语言标准——ANSI X3.159-1989，简称“C89”，不过人们也习惯称其为“ANSI C”。C89在1990年被[国际标准化组织](https://baike.baidu.com/item/国际标准化组织/779832)（International Standard Organization，[ISO](https://baike.baidu.com/item/ISO/6210025)）一字不改地采纳，ISO官方给予的名称为：ISO/IEC 9899，所以ISO/IEC9899:1990也通常被简称为“C90”。1999年，在做了一些必要的修正和完善后，ISO发布了新的C语言标准，命名为ISO/IEC 9899:1999，简称“[C99](https://baike.baidu.com/item/C99)”。
>
> 在2011年12月8日，ISO又正式发布了新的标准，称为ISO/IEC9899:2011，简称为“[C11](https://baike.baidu.com/item/C11)”。

## 语言特点

### 主要特点

C语言是一种结构化语言，它有着清晰的层次，可按照模块的方式对程序进行编写，十分有利于程序的调试，且c语言的处理和表现能力都非常的强大，依靠非常全面的运算符和多样的[数据类型](https://baike.baidu.com/item/数据类型/10997964)，可以轻易完成各种数据结构的构建，通过指针类型更可对内存直接寻址以及对硬件进行直接操作，因此既能够用于开发系统程序，也可用于开发应用软件。通过对C语言进行研究分析，总结出其主要特点如下：

+ 简洁的语言

  C语言包含的各种[控制语句](https://baike.baidu.com/item/控制语句/10507605)仅有9种，关键字也只有32个，程序的编写要求不严格且以小写字母为主，对许多不必要的部分进行了精简。实际上，语句构成与硬件有关联的较少，且C语言本身不提供与硬件相关的输入输出、文件管理等功能，如需此类功能，需要通过配合编译系统所支持的各类库进行编程，故c语言拥有非常简洁的编译系统。

+ 具有结构化的控制语句

  C语言是一种结构化的语言，提供的控制语句具有结构化特征，如for语句、if...else语句和[switch](https://baike.baidu.com/item/switch/18601752)语句等。可以用于实现函数的逻辑控制，方便面向过程的程序设计。

+ 丰富的数据类型

  C语言包含的数据类型广泛，不仅包含有传统的字符型、整型、浮点型、数组类型等数据类型，还具有其他编程语言所不具备的数据类型，其中以指针类型数据使用最为灵活，可以通过编程对各种数据结构进行计算。

+ 丰富的运算符

  C语言包含34个[运算符](https://baike.baidu.com/item/运算符/7752795)，它将赋值、括号等均视作运算符来操作，使C程序的表达式类型和运算符类型均非常丰富。

+ 可对[物理地址](https://baike.baidu.com/item/物理地址/2901583)进行直接操作

  C语言允许对[硬件](https://baike.baidu.com/item/硬件/479446)内存地址进行直接读写，以此可以实现汇编语言的主要功能，并可直接操作硬件。C语言不但具备高级语言所具有的良好特性，又包含了许多低级语言的优势，故在系统软件编程领域有着广泛的应用。

+ 代码具有较好的可移植性

  C语言是面向过程的编程语言，用户只需要关注所被解决问题的本身，而不需要花费过多的精力去了解相关硬件，且针对不同的硬件环境，在用C语言实现相同功能时的代码基本一致，不需或仅需进行少量改动便可完成移植，这就意味着，对于一台计算机编写的C程序可以在另一台计算机上轻松地运行，从而极大的减少了程序移植的工作强度。

+ 可生成高质量、目标代码执行效率高的程序

  与其他高级语言相比，C语言可以生成高质量和高效率的目标代码，故通常应用于对[代码质量](https://baike.baidu.com/item/代码质量/8863758)和执行效率要求较高的[嵌入式系统](https://baike.baidu.com/item/嵌入式系统/186978)程序的编写。



### 特有特点

C语言是普适性最强的一种计算机程序编辑语言，它不仅可以发挥出高级编程语言的功用，还具有汇编语言的优点，因此相对于其它编程语言，它具有自己独特的特点。具体体现为以下三个方面：

其一，广泛性。C语言的运算范围的大小直接决定了其优劣性。C语言中包含了34种运算符，因此运算范围要超出许多其它语言，此外其运算结果的表达形式也十分丰富。此外，C语言包含了字符型、[指针](https://baike.baidu.com/item/指针/2878304)型等多种数据结构形式，因此，更为庞大的数据结构运算它也可以应付。

其二，简洁性。9类控制语句和32个关键字是C语言所具有的基础特性，使得其在计算机应用程序编写中具有广泛的适用性，不仅可以适用广大编程人员的操作，提高其工作效率，同时还能够支持高级编程，避免了语言切换的繁琐。

其三，结构完善。C语言是一种结构化语言，它可以通过组建模块单位的形式实现[模块化](https://baike.baidu.com/item/模块化/3295536)的应用程序，在系统描述方面具有显著优势，同时这一特性也使得它能够适应多种不同的编程要求，且执行效率高。



### 缺点

1. C语言的缺点主要表现为数据的封装性弱，这一点使得C在数据的安全性上有很大缺陷，这也是C和C++的一大区别。
2. C语言的语法限制不太严格，对变量的类型约束不严格，影响程序的安全性，对[数组下标越界](https://baike.baidu.com/item/数组下标越界)不作检查等。从应用的角度，C语言比其他高级语言较难掌握。也就是说，对用C语言的人，要求对程序设计更熟练一些。



# 变量与常量

## 变量

### 什么是变量？

> 变量是一个抽象概念，你可以理解成变量是一个装物品的盒子。

### 变量的初始化

> 如果不对局部变量进行初始化，那么局部变量都是随机值。
>
> 全局变量不初始化会默认初始化成0

### 作用域

> 变量的活动范围，一旦出了该范围就会死亡（被释放）

### 生命周期

> 生命周期指的是变量定义到释放的时间范围，所谓的释放，指的是曾经开辟的空间“被释放”

### 全局变量

+ 生命周期

  整个项目的生命周期（ps：程序结束了，全局变量才死亡）

+ 作用域

  在整个项目内都有效

### 局部变量

+ 生命周期

  进作用域是它生命周期的开始，出作用域是它生命周期的结束。

+ 作用域

  当前范围内有效（ps：指的是在“{}”内就是它的作用域一旦出了“{}”就会失效）

**总结：** 能被修改的盒子就是变量，变量的作用域跟生命周期挂钩，出了作用域生命周期也就结束了，在”{}“内定义的变量称为局部变量，在”{}“外定义的变量称为全局变量。

全局变量与局部变量的区别：作用域不同，生命周期不同。

## 常量

### 什么是常量？

> 常量是一个抽象概念，你可以理解成封闭的通明盒子，只能看到里面的东西无法对里面的东西进行更换。

### 字面常量

字面常量就是`123`这样直接显示打出来的内容就是字面常量。

### cosnt修饰的常量

> `const`修饰的常量本质是一个变量，但是它的属性被`const`修饰了，具有了常量的无法被修改属性。（ps：简单理解就是一个盒子可以打开里面的东西可以更换，而`cosnt`相当于钉子你用这个钉子把盒子开口钉住了，无法取出更换了。）

### #define定义的标识符常量

> `#define`定义的标识符常量，本质是一个字面常量，你看起来使用不像是常量，但是它的底层原理是交换标识符。

### 枚举常量

> 枚举常量是一种一个一个列举出了的事物或者其它东西，但是本质都是字面常量。



# 内置类型

## 什么是内置类型？

C语言本身自带的类型就是内置类型，这些类型都是关键字。

## 字符型家族

+ 默认有符号

  类型前面默认+`signed`，手动显示+`signed`效果一样。

  ``` c
  char		//字符型
  ```

+ 无符号

  在类型前面+`unsigned`变成无符号字符型

## 整形家族

+ 默认有符号

  类型前面默认+`signed`，手动显示+`signed`效果一样。

  ``` c
  short		//短整形
  int			//整形
  long		//长整形
  long long	//更长的整形
  ```

+ 无符号

  在类型前面+`unsigned`变成无符号整形

## 浮点型家族

+ 默认有符号

  类型前面默认+`signed`，手动显示+`signed`效果一样。

  ``` c
  float		//单精度浮点型
  double		//双精度浮点型
  ```

+ 无符号

  在类型前面+`unsigned`变成无符号浮点型

### 浮点型的比较相等

> 浮点型数据在机器当中经过运算重新存储时里面的数据会发生一些微小的变化会导致数据不相等的问题，这种问题我们称之为数据损失，所以我们在对浮点型进行比较相等的时候不能直接用等号比较。
>
> 而是使用误差值进行比较，再可接受误差范围内进行比较相等。
>
> ```c
> #include <stdio.h>
> #include <math.h>
> #include <float.h>
> #define EPS 0.0000001
> 
> 
> int main()
> {
> 	double x = 1.0;
> 	double y = 0.9;
> 
> 	//判断是否等于0使用自定义EPS
> 	if (fabs((x - y) - 0.1) < EPS && fabs((x - y)- 0.1) > -EPS)
> 	{
> 		printf("yes\n");
> 	}
> 	else
> 	{
> 		printf("no\n");
> 	}
> 
> 	//判断是否相等使用自定义EPS
> 	if (fabs((x - y) - 0.1) < EPS)
> 	{
> 		printf("yes\n");
> 	}
> 	else
> 	{
> 		printf("no\n");
> 	}
> 
> 	//判断是否等于0 DBL_EPSILON
> 	if (fabs((x - y) - 0.1) < DBL_EPSILON && fabs((x - y) - 0.1) > -DBL_EPSILON)
> 	{
> 		printf("yes\n");
> 	}
> 	else
> 	{
> 		printf("no\n");
> 	}
> 
> 	//判断是否相等 DBL_EPSILON
> 	if (fabs((x - y) - 0.1) < DBL_EPSILON)
> 	{
> 		printf("yes\n");
> 	}
> 	else
> 	{
> 		printf("no\n");
> 	}
> 
> 	return 0;
> }
> ```
>
> 

## 无符号类型与有符号类型的区别

无符号类型和有符号类型的唯一区别：

1. 无符号只有正数，没有负数，而没有负数可以表示更大的值。
2. 有符号有正负数之分，而这样无法表示更大的数。



# 自定义类型

## 数组

### 什么是数组？

数组就是多个相同类型的元素在一个盒子内就成了一个组。

### 数组的创建

**数组：** 数组类型 数组名[元素个数]

**例子：**

```c
int arr[3];
```

**注意：** c99前的标准元素个数必须是字面常量，c99及之后才支持变量定义元素个数。

### 数组初始化

==如果不对数组初始化iumang 里面的元素都是随机值==

+ 完全初始化

  ```c
  int arr[3] = { 1, 2, 3 };
  ```

+ 不完全初始化

  ```c
  int arr[3] = { 1 };//第一个元素初始化成1，其它元素默认初始化成0
  int arr[3] = { 0 };//所有元素默认初始化成0
  ```

+ 不指定大小初始化

  ```c
  int arr[] = { 1 };//根据实际元素设置数组大小
  ```

#### 字符型数组初始化和字符串初始化的区别

##### 什么是字符型数组初始化？

如果初始化的内容都是一个一个“单引号”括起来的字符，那么这个数组就是字符型数组，字符数组的时候是给多少元素就有多少元素，而在打印字符型数组的内容或计算字符型数组大小的时候会出一些问题，因为字符数组计算和打印是根据`\0`来判断字符的结束，如果没有初始化的时候末尾没有`\0`那么会出现一些奇怪的现象。

```c
char arr[3] = { 'a', 'b', 'c' };//错误的字符型数组初始化，不会自动+\0需要手动+\0
char arr[4] = { 'a', 'b', 'c', '\0' };//正确的字符型初始化
```

##### 什么是字符串初始化？

字符串本质也是字符型数组但是它初始化的时候不是单个初始化看起来像一个串，所以这种形式的字符型数组大家都叫为字符串，字符串和字符型数组的区别在于初始化，字符串是以“双引号”括起来的一串字母，而字符型数组是多个“单引号”括起来的单个字符组成的数组，字符串默认初始化会自带\0，前提是空间要给他预留一个否则也会出现字符型的状况。

```c
char arr[] = "abc";
char arr[4] = "abc";//这个形式和上面的效果等价，但是平常使用都是习惯写上面那种的形式
char arr[3] = "abc";//这种形式是错误的，没有给\0预留一个空间会导致出现和字符型数组一样的问题
```

**总结：** 字符串和字符型数组本质都是字符型数组，但是字符串会带`\0`而字符型数组不会带`\0`，其次字符型数组的初始化太难受了😫一般都是使用字符串初始化方便其次会自带`\0`。

### 多维数组

多维数组其实是存储低维数组的一种数组，理论上来讲只要你想这个数组维度可以是`∞`高，实际开发中使用最高的也就是二维数组。

![image-20220109164447507](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220109164447507.png)

#### 多维数组的创建

多维数组的创建和一位数组一样不过唯一的区别是，维度每高一层就会多一个`[]` 我们可以根据`[]`的个数来判断是几维数组。

```c
int arr1[] = { 1, 2, 3 };//一维数组
int arr2[2][3] = { {1, 2, 3 }, {4, 5, 6 } };//二维数组
```



### 数组的存储

数组的存储一般都是由低到高这样递增，一个数组的大小是由元素个数×元素类型。

```c
#include <stdio.h>

int main()
{
	int arr[2][3] = { {1, 2, 3 }, { 4, 5, 6 } };

	int i = 0;
	int j = 0;

	for (i = 0; i < 2; i++)
	{
		for (j = 0; j < 3; j++)
		{
			printf("arr[%d][%d]的地址：%p\n", i, j, &arr[i][j]);
		}
	}

	return 0;
}
```



![image-20220109165913942](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220109165913942.png)

### 数组名不是首元素的两种情况

绝大多数情况下数组名就是该数组的首元素地址，而有两种情况不是该数组的首元素地址而是整个数组的首地址。

1. sizeof（数组名）

   在这里计算的不是数组首元素的大小而是计算整个数组的大小

2. &数组名

   这里的取地址取的不是首元素地址而是整个数组的首地址。

### 柔性数组

> 柔性数组是C99标准才支持的一种语法格式，它的作用是定义一个未知大小的数组，但是定义这个数的前提是在结构体内且该结构体至少有一种数据类型（柔性数组本身除外）才能定义柔性数组且柔性数组必须是在该结构体的最后一个成员变量。
>
> 柔性数组的大小不会计算到结构体的大小内。

#### 定义

> 柔性数组不能直接像常规结构体那样定义必须得先创建一个结构体指针类型指向堆内申请的空间来创建。申请大小的时候必须把原结构体成员变量大小算进去（柔性数组除外）。

```c
#include <stdio.h>
#include <stdlib.h>

struct A
{
	int i;
	int arr[];//柔性数组必须是最后一个成员变量，且前面必须有一个成员变量。
};

int main()
{
	//不能直接定义，必须定义成指针来使用，把结构体A的大小算进去再加柔性数组的大小
	struct A* pa = (struct A*)malloc(sizeof(struct A) + sizeof(int) * 10);
	if (!pa)
	{
		printf("内存申请失败！\n");
		exit(-1);
	}

	pa->i = 10;
	int i = 0;

	for (i = 0; i < pa->i; i++)
	{
		pa->arr[i] = i;
	}

	for (i = 0; i < pa->i; i++)
	{
		printf("%d ", pa->arr[i]);
	}

	free(pa);
	pa = NULL;

	return 0;
}
```

#### 特点

> 1. 结构中的柔性数组成员前面至少得有一个其它成员
> 2. sizeof返回的这种结构体大小不包括柔性数组的内存
> 3. 包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。



## 结构体

### 什么是结构体？

结构体是一种描述现实中的复杂对象，C语言内置的类型无法满足这种复杂对象的描述，所以C语言提供了一种自定义类型规则，你可以定义出任意类型，这个类型一般用于描述复杂场景。

**例如：** 描述一个学生，用C语言的类型是无法满足的，只能用C语言内置类型组合出一个新的类型，这种类型我们称之为结构体。

### 结构体的创建

**结构体语法：** `struct 新类型名`  {...};

**例子：**

```c
struct students //自定义的学生类型
{
    short ID;
    short age;
    char[20] name;
};
```

### 结构体的初始化

```c
#include <stdio.h>

//定义结构体A并创建全局变量初始化
struct A
{
	char name[20];
	int age;
}a1 = { "张三", 30 };

//定义结构体
struct B
{
	char name[20];
	int age;
};

//创建全局变量
struct B b1 = { "李四", 20 };

//结构体定义别名C, C == struct CBokk
typedef struct CBook
{
	char name[20];
	int age;
}C;


int main()
{
	//定义局部变量
	struct B b2 = { "王五", 22 };

	//别名定义局部变量结构体
	C c1 = { "赵六", 23 };

	printf("%s\t%d\n", a1.name, a1.age);
	printf("%s\t%d\n", b1.name, b1.age);
	printf("%s\t%d\n", b2.name, b2.age);
	printf("%s\t%d\n", c1.name, c1.age);

	return 0;
}
```

### 匿名结构体

```c
#include <stdio.h>

//不建议使用这种匿名结构体
//别名定义匿名结构体，不过能支持任意地方创建和初始化和使用正常的结构体没有区别
typedef struct
{
	char naem[20];
	int age;
}S;

//匿名结构体，使用前必须在定义结构体后就创建并初始化
struct
{
	char name[20];
	int age;
}a = { "李四", 33 };

int main()
{
	S s1 = { "张三", 20 };

	printf("%s\t%d\n", s1.naem, s1.age);
	printf("%s\t%d\n", a.name, a.age);

	return 0;
}
```



### 结构体传递参数

#### 值传递

> 结构体传参时值传递形参进行接收是拷贝的形式该拷贝的变量是在栈里开辟空间，由于栈很小如果结构体过大会导致栈溢出。

#### 址传递

> 结构体传参时址传递形参是进行接收的时候只占4/8个字节不管该形参多大都是占这么大也不会发生拷贝导致效率下降，且传递的是原结构体变量过去不会多开很多空间从而不会导致栈溢出。

**总结：** 任何情况下都不建议值传递，尽量用址传递从而提高效率和降低空间占用。

### 结构体对齐

#### 结构体对齐规则

> 1. 结构体成员是从第一个地址0开始
>
> 2. 结构体成员存放的段空间一定是该成员类型的倍数，如果不是就浪费该空间直到找到倍数地址段
>
> 3. Windows下结构体有默认对齐数，而Linux没有对齐数
>
>    VS默认对齐数是8
>
> 4. 占用空间总是以较大的成员倍数作为对齐数（结构体嵌套结构体成员不会作为对齐数）

**例子：**

```c
#include <stdio.h>

struct A
{
	char name;//1字节
	int age;//4字节
	char sex;//1字节
};

int main()
{
	printf("struct A的大小：%d字节\n", sizeof(struct A));//结构体大小

	return 0;
}
```

![image-20220128080218393](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220128080218393.png)

![image-20220128080628979](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220128080628979.png)





#### 修改默认对齐数

`#pragma pack()`用于修改默认对齐数，如果修改成1那么就没有对齐数了。

**例子：**

```c
#include <stdio.h>

//默认对齐数修改成1
#pragma pack(1)
struct A
{
	char name;
	int age;
	char sex;
};
//恢复默认对齐数
#pragma pack()

int main()
{
	printf("struct A的大小：%d字节", sizeof(struct A));

	return 0;
}
```

![image-20220128082516458](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220128082516458.png)

![image-20220128082534420](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220128082534420.png)

#### 为什么要内存对齐？

> 1. 平台原因（移植性原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取特定的数据类型，否则抛出硬件异常。
> 2. 性能原原因：数据结构J（尤其是栈）应尽可能的在自然边界对齐，原因在于为了访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问只需要做一次。

**总结：** 结构体内存对齐是一种空间换时间的做法。



### 位段

#### 位段的定义

```c
struct A
{
	int a : 3;//占用3个比特位
	int b : 20;//占用20个比特位
	int c : 9;//占用9个比特位
	//大小：4个字节
};
```

#### 位段的内存分配

> 1. 位段的成员可以是int或者char类型
> 2. 位段的空间上是按照需要以4个字节或者1个字节的方式来开辟的
> 3. 位段涉及很多不确定因素，位段是不夸平台的，注重移植性的程序应该避免使用位段。

**例子：**

```c
struct A
{
	int a : 3;//占用3个比特位
	int b : 20;//占用20个比特位
	int c : 9;//占用9个比特位
	//大小：4个字节
};
```

![image-20220128084220476](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220128084220476.png)

#### 位段的跨平台问题

> 1. int位段被当成有符号数还是无符号数不确定
> 2. 位段中最大为的数目不确定（16位机器最大16，32位机器最大32，写成27在16位机器上会出现问题）
> 3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准未定义
> 4. 当一个结构包含两个位段，第二个位段尘缘比较大，无法容纳第一个位段剩余的位时，时舍弃剩余的位还是利用，这时不确定的。
>
> **总结：** 位段跟结构相比，位段可以达到同样的效果，但是可以狠好的节省空间，但是有跨平台的问题存在。



#### 位段的应用

![image-20220128091237090](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220128091237090.png)



#### offsetof

> 计算结构体的偏移量

##### 实现

```c
```



### 联合体

> 联合体只能使用C语言的内置类型定义成员变量，它和结构体唯一的区别就是内存共用，看似有很多变量其实只能用一个。
>
> 它的大小是最大的成员变量大小。

#### 定义

```c
union B
{
	int age;
	char arr;
	int set;
};
```

**总结：** 联合的成员是共用同一块内存空间，这样一个联合体变量的大小，至少是最大成员的大小（因为联合体至少得有能力保存最大的成员变量。



# ASCII码表

![image-20220109131245211](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220109131245211.png)

ASCII码表是用来给计算机换算成相应值的，因为计算机是用电驱动的，电信号只能表示0和1不能表示其它的，而我们这些英文和中文本质都是一个值，不过是经过ASCII码表换过的值。

# 注释

## 什么是注释

注释的意思是让编译器无视被注释的内容，被注释的内容是给人看的，机器不需要理解。

## 注释风格

### C语言注释风格

```c
/*sdgag
dfaf
fasdf*/
```

1. 优点

   支持大面积注释

2. 缺点

   不支持嵌套注释

### C++注释风格

```cpp
//dfsafsf
//asdfasf
//daf
```

1. 有点支持嵌套注释
2. 缺点不支持大面积注释

# 🎈分支语句

## 什么是分支语句？

> 相当于现实生活中的选择，我今天选择喝奶茶呢？还不是不喝奶茶呢？而计算机的选择也是如此，如果你想喝奶茶就打1，那么计算机会给你买一杯奶茶，如果不想喝就什么都不做。

![image-20220107191910507](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220107191910507.png)

## 💨分支语句关键字

### if和else

**用法：** 

```c
if (表达式)
{
    //...
}
else
{
    //...
}
```

#### else if多分支

**用法：**

```c
if (表达式1)
{
	//...
}
else if (表达式2)
{
    //...
}
else if (表达式3)
{
    //...
}
//else if...
else
{
    //...
}
```

#### 嵌套if和多分支

`if`语句支持任何形式的嵌套

**用法：**

```c
if (表达式1)
{
    if (表达式2)
    {
        //...
    }
}
```

### switch关键字

`switch`和`if`一样不过唯一的区别就是，它会从匹配到的位置一直往下执行，直到语句执行完毕。

#### default关键字

`default`和`else`一样的作用，都是在你啥都不选的时候的默认选项。

#### case关键字

`case`相当于`else if`的作用用于多分支选择。

#### break关键字

`break`用于跳出不想执行的场景，因为`switch`一旦匹配到会从匹配到的位置一直往下执行，有时候并不需要全部执行就会使用到`break`。

### switch使用方式

```c
switch (表达式)
{
    case 常量1:
        //...
        break;
    case 常量2:
        //...
        break;
	//case 常量3...
    default:
        //...
        break;
}
```

**注意：** ==`case` 后面必须是常量否则会报error。==

**总结：** 分支语句的使用具体根据场景使用不同场景使用不同分支语句关键字，所有分支语句都支持嵌套。

# ✨循环语句

## 什么是循环语句？

和`if`语句一样，不过唯一的区别是，需不需要做而不是选择一次，直到不满足条件才停止。

![image-20220107194555488](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220107194555488.png)

## while关键字

`while`语句你可以理解成一个`if`不过它和`if`的区别是`while`一直重复执行直到符合某种条件才停止，`if`只会执行一次。

**用法：**

``` c
while (表达式)
{
    //...
}
```

## for关键字

它和`while`一样不过唯一的区别是用法，不过有一点优点是比`while`好的，满足条件的方法一定会增加永远不会漏写，而`while`当里面的内容过多可能会造成漏写满足条件的方法导致死循环。

**用法：**

```c
for (表达式1; 表达式2; 表达式3)
{
    //...
}
```



![image-20220107195951510](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220107195951510.png)![image-20220107200223935](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220107200223935.png)

## do while关键字

它和前面两个的循环不太一样，它是不管任何条件先执行一次后判断是否需要继续执行。

**用法：**

```c
do
{
    //..
} while (b)
```

# 🕹goto语句

用于跳转到指定位置，这个功能很强大但也很致命，因为可以随意跳转会导致程序执行顺序改变，从而导致结果补可预测。

**用法：**

```c
int main()
{
    test1://标签，跳转的地方
    
    while (表达式)
    {
        //...
        while (表达式)
        {
            goto test1;//跳转到标签所在位置，重新执行
        }
    }
    
    return 0;
}
```

**注意：** 实际开发中无论如何都不能使用`goto`语句，它很容易造成致命bug而这种bug是难以解决的！！！



# 🎃🎃🎃32个关键字

```c
auto double int struct break else long switch

case enum register typedef char extern return union

const float short unsigned continue for signed void

default goto sizeof volatile do if while static
```

## 数据类型关键字

1. 基本数据类型（5个）

   + void

     声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果

   + char

     字符型类型数据，属于整型数据的一种

   + int

     整型数据，通常为编译器指定的机器字长

   + float

     单精度浮点型数据，属于浮点数据的一种

   + double

     双精度浮点型数据，属于浮点数据的一种

2. 类型修饰关键字（4个）

   + short

     修饰int，短整型数据，可省略被修饰的int。

   + long

     修饰int，长整形数据，可省略被修饰的int。

   + signed

     修饰整型数据，有符号数据类型

   + unsigned

     修饰整型数据，无符号数据类型

3. 复杂类型关键字（5个）

   + struct

     结构体声明

   + union

     共用体声明

   + enum

     枚举声明

   + typedef

     声明类型别名

   + sizeof

     计算类型或类型变量的大小

4. 存储级别关键字（6个）

   + auto

     指定为自动变量，由编译器自动分配及释放。通常在栈上分配

   + static

     指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部

   + register

     指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数

   + extern

     指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的对象的一个“引用“

   + const

     与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变）

   + volatile

     与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值

## 流程控制关键字

1. 跳转结构（4个）

   + return

     用在函数体中，返回特定值（或者是void值，即不返回值）

   + continue

     结束当前循环，开始下一轮循环

   + break

     跳出当前循环或switch结构

   + goto

     无条件跳转语句

2. 分支结构

   + if

     条件语句

   + else

     条件语句所有条件不满足默认执行它和`if`搭配使用

   + switch

     开关语句

   + case

     开关语句的标记

   + default

     开关语句默认执行，当其它的条件不满足就执行它。

3. 循环结构

   + for

     for循环结构，for(1;2;3)4;的执行顺序为1->2->4->3->2...循环，其中2为循环条件

   + do

     do循环结构，do 1 while(2);的执行顺序是1->2->1...循环，2为循环条件

   + while

     while循环结构，while(1) 2;的执行顺序是1->2->1...循环，1为循环条件
   
   

## 关键字详细介绍

### auto

> 修饰变量表示该变量是一个局部变量，一般适用于老机器，目前的编译器都会默认是局部变量，所以auto被淘汰了几乎没用。
>
> **使用案例：**
>
> ```c
> {
>     auto int b = 20;
> }
> 
> auto int c = 30;//这样子不行会报错，因为这样子就是全局了
> 
> int main()
> {
>     auto int a = 20;
>     
>     return 0;
> }
> ```

### register

> 一般用于把变量载入寄存器当中，当时CPU内的寄存器容量很小，所以不能随便的都放入寄存器当中，放入寄存器当中能提高程序的执行效率，因为电脑的数据传输结构是呈现一个金字塔状。
>
> 越接近CPU容量越小，运行效率也越高，造价也越贵。被register修饰的变量是不可以取地址的。因为寄存器的内存是不能被用户访问的。
>
> ![image-20220204212142358](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220204212142358.png)
>
> **使用案列：**
>
> ```c
> int main()
> {
> 	register int c = 30;    
> }
> ```

### extern

> 对一个变量或者函数进行声明，该声明不会开辟空间，如果函数没被声明缺能运行是因为该方法存在。
> 一般声明用在的地方通常是.h文件内，.h文件内的所有东西建议声明都带上extern关键字虽然不带也可以。
>
> **使用案列：**
>
> ```c
> extern int b;
> extern void Add(int a, int b);
> ```

### static

> static修饰全局变量，该变量旨在文本文件内被访问，不能被外部其它文件直接访问。
> static修饰的函数，该函数只能在文本文件内被访问，不能在外部或其它文件直接访问。
>
> 如果作用于局部变量会延长它的生命周期至和全局变量一样，同时它的存放点会放到静态区。
>
> **使用案列：**
>
> ```c
> static a = 10;
> static int Add(int a, int b)
> {
>     return a + b;
> }
> 
> int main()
> {
>     static b = 30;
>     
>     return 0;
> }
> ```
>



### signed

> 表示该类型是有符号的，默认就是有符号的，一般不需要加上此关键字。
>
> **使用案列：**
>
> ```c
> signed int a = 0;
> ```



### unsigned

> 表示该类型是一个无符号，可以使类型表示更大的数据。
>
> ```c
> unsigned int a = 0;
> ```

### if

> 用于判断是否要执行某个代码块。
>
> **判断流程：**
>
> 1. 表达式的最终结果
> 2. 判断表达式
> 3. 执行
>
> **使用案列：**
>
> ```c
> int main()
> {
>     if (表达式)//表达式为真就执行为假就不执行下面的代码块
>     {
>         //...
>     }
> }
> ```

### else if

> 作为`if`的另一个条件分支，判断逻辑和if相同。
>
> **使用案列：**
>
> ```c
> int main()
> {
>     if (表达式)
>     {
>         //...
>     }
>     else if (表达式)//多分支
>     {
> 		//...	
>     }
> }
> ```

### else

> 匹配最近的一个if语句，当所有条件都不满足时执行`else`下面的内容。
>
> **使用案列：**
>
> ```c
> int main()
> {
>     if (表达式)
>     {
>         //...
>     }
>     else if(表达式)
>     {
>         //...
>     }
>     else //当所有分支都不满足，就执行下面的代码块
>     {
>        //... 
>     }
> }
> ```



### switch

> 开关语句它只有判断判断是否为真，只能对常量和整型变量表达式进行判断。
>
> 1. 为真就进去执行，假反之。
>
> **使用案列：**
>
> ```c
> int main()
> {
>     switch (常量表达式)//如果为真就执行代码块的内容
>     {
>             //...
>     }
> }
> ```



### case

> 用于搭配`switch`使用，相当于if里面的分支不过只会配对，一旦配对上就一直往下执行。
>
> **使用案列：**
>
> ```c
> int main()
> {
>     switch (常量表达式)
>     {
>         case 1://用于配对常量表达式，一旦配对就从配对上的地方依次往下执行所有
>             //...
>         case 2:
>             //...
>     }
> }
> ```

### default

> 作用和`else`一模一样用于作为不匹配的执行路线，不过和`else`的区别在于它对于使用位置不限制。
>
> **使用案列：**
>
> ```c
> int main()
> {
>     switch (常量表达式)
>     {
>         case 1:
>             //...
>         case 2:
>             //...
>         default://当所有条件都匹配不到执行该行下的内容
>             //...
>     }
> }
> ```



### break

> 跳出循环的关键字，但是搭配`case`使用的效果跟`else if`就一致了。
>
> **使用案列：**
>
> ```c
> int main()
> {
>     switch (常量表达式)
>     {
>         case 1:
>             //...
>             break;//当执行到break就不会依次往下执行而是退出该开关
>         case 2:
>             //...
>             break;
>         default:
>             //...
>             break;
>     }
> }
> ```
>

### while

> 循环执行一段代码块，判定条件和`if`一样。
>
> **使用案列：**
>
> ```c
> int main()
> {
>     int i = 0;//循环变量
>     
>     while (i < 10)//循环条件
>     {
>         printf("hello\n");//循环内容
>         i++;//退出条件
>     }
> }
> ```

### do

> 跟`while`一样区别在于它无论如何都会先执行一遍代码块的内容。
>
> **使用案列：**
>
> ```c
> int main()
> {
>     int i = 10;
>     
>     do //先执行一遍再判断是否需要执行
>     {
>         printf("hello\n");//循环内容
>         i++;//退出循环条件
>     } while(i < 10)//循环条件
> }
> ```

### for

> 它相对来说比`while`好用因为它的循环条件、循环变量和退出循环都集中在一块，而`while`都是分开的当代码量过大可能回忘记写退出循环条件。
>
> **使用案列：**
>
> ```c
> int main()
> {
>     int i = 0;
>     
>     //第一步先执行变量初始化，第二部执行条件判断，第三步执行代码块内容，最后一步才是执行退出循环条件。
>     for (i = 0; i < 10; i++)
>     {
>         printf("hello\n");
>     }
>     
>     return 0;
> }
> ```

### continue

> 执行到`continue`关键字后面的内容不再执行且结束本轮循环。
>
> **使用案列：**
>
> ```c
> int main()
> {
>     int i = 0;
>     
>     while (i < 10)
>     {
>         if (i == 5)
>         {
>             i++;
>             continue;
>         }
>         
>         printf("%d ", i);
>         
>         i++;
>     }
> }
> ```

### goto

> `goto`用于跳转到标签位置，它非常强大但也非常难以驾驭，一般开发都是不建议使用的。
>
> **使用案列：**
>
> ```c
> int main()
> {
>     int i = 0;
>     
>     head:
>     
>     while (i < 10)
>     {
>         if (i == 5)
>         {
>             i++;
>             goto head;//跳转到head标签位置
>         }
>         printf("%d ", i);
>         i++;
>     }
> }
> ```

### void

> 一般用于作为形参和返回值使用表示该函数没有返回值或形参，不能定义变量。
>
> `void*`可以被任何指针接收，并且可以创建变量等等操作。
>
> **使用案列：**
>
> ```c
> void test1()//明确表示没有返回值
> {
>     
> }
> 
> void test2(void)//明确表示没有返回值和参数
> {
>     
> }
> ```

### int

> 用于定义一个整型变量，默认是有符号的整型变量。
>
> **使用案列：**
>
> ```c
> int a = 10;
> ```

### char

> 用于定义一个字符型变量，默认有符号的字符型变量。
>
> **使用案列：**
>
> ```c
> char ch = 'a';
> ```

### short

> 用于定义一个短整型变量，默认是有符号的短整型变量。
>
> **使用案列：**
>
> ```c
> short a = 20;
> ```

### long

> 用于定义一个长整型变量，默认是有符号的长整型变量。
>
> **使用案列：**
>
> ```c
> long a = 20;
> ```

### flaot

> 用于定义一个单精度浮点型变量。
>
> **使用案列：**
>
> ```c
> float a = 2.5f;
> ```

### double

> 用于定义一个双精度浮点型变量。
>
> **使用案列：**
>
> ```c
> double b = 2.5;
> ```

### sizeof

> 用于计算一个变量或类型关键字的所占字节大小。
>
> 当在计算变量名时可以不带括号，计算类型关键字必须带上括号。
>
> 在`sizeof`里面发生的任何运算都不会生效，因为错开了，`sizeof`是链接时发生，而运算是在编译阶段发生，所以在`sizeof`里面的运算会无效。
>
> **使用案列：**
>
> ```c
> int main()
> {
>     int a = 10;
>     
>     printf("%d\n", sizeof a);
>     printf("%d\n", sizeof(a));
>     printf("%d\n", sizeof(int));
> }
> ```

### return

> 当使用函数时需要带回一个值给调用方时，需要用到`return`来带回。
>
> 返回形式通常是把结果的值放在寄存器内不管调用方是否接受该返回值，如果接收返回值就把存放在寄存器的返回值返回给调用方。
>
> **使用案列：**
>
> ```c
> int Add(int a, int b)
> {
>     return a + b;
> }
> 
> int main()
> {
>     int sum = Add(30, 40);
>     printf("sum：%d\n", sum);
>     
>     return 0;
> }
> ```

### const

> const修饰的变量都无法修改，具有常属性，但是可以通过指针间接修改该变量。
>
> const修饰变量不分在类型前还是后。
>
> const修饰指针变量，在\*前会让指针指向的地址无法更改，在\*后面修饰的是该指针变量不解引用无法修改。
> 如果两边都有说明该指针变量无法修改指向和自己指向发地址内容。
>
> const修饰数组和修饰变量一摸一样的效果
>
> **使用案列：**
>
> ```c
> int main()
> {
> 	const int a = 10;//a不能被修改具有常属性 int const a = 10;这两个相等
> 
> 	const int* p1 = &a;
> 	int const* p2 = &a;//这两个相等，表示p2和p1指针变量指向的指针无法被修改
> 
> 	int* const p3 = &a;//表示该指针变量不能修改指向，永远的指向a
> 
> 	const int* const p4 = &a;//表示该指针变量不能修改指针且也不能修改指向。
> 
> 	return 0;
> }
> ```

### volatile

> 这个关键字用到的场景比较少，所以我们简单认识一下，`volatile`主要用于稳定变量的，有时候变量很少的话cpu为了提高效率会优化把变量放到寄存器存储，而读取时不在是去内存中拿数据，在一些情况下这样子做可能会出现问题，而`volatile`的作用是让cpu去内存中拿，而不是在寄存器当中弄一份使用。
>
> **总结：** 变量被`volatile`修饰不被编译器优化，让它正常访问，因为该变量可能会改变。
>
> **使用案列：**
>
> ```c
> int main()
> {
>     volatile int b = 20;
> }
> ```

### struct

> 用于定义一个自定义类型，用来描述复杂的事物或事件。
>
> **使用案列：**
>
> ```c
> struct std
> {
>     char ch;
>     short age;
>     int a;
>     long b;
> };
> ```

### union

> 创建一个自定义类型，不过该自定义类型的所占大小是以最大成员为基准且空间也是共用的。
>
> **使用案列：**
>
> ```c
> union stu
> {
>     char ch;
>     short age;
>     int a;
>     long b;
> };
> ```

### typedef

> 用于给类型重新定义一个新名字。
>
> **使用案列：**
>
> ```c
> typedef unsigned int u_int;
> 
> int main()
> {
>     u_int a = 10;
> }
> ```

### enum

> 用于定义一个枚举类型，枚举类型本质是一个字面常量的数组。
>
> **使用案列：**
>
> ```c
> enum sex
> {
>     man,
>     
> }
> ```
>
> 



# ✨✨✨函数

## 什么是函数？

C语言里面的函数是一个子程序，一个大型项目是由多个子程序组成的项目，而每个子程序是用于执行某个特定的任务。

## 函数的组成

函数是由三个模块组成，返回值、参数、函数名

### 返回值

#### 什么是返回值？

返回值是一种结果，当一个函数执行完了必须返回一个结果，这个结果通常是给调用者看的。

**例子：**

我让你去帮我买一杯奶茶，而你买完奶茶回来的时候只有两种结果。

1. 买到奶茶
2. 没买到奶茶

而我让你去买奶茶我不会关心你怎么去买的，我只关心你有没有买回来这就是一个结果，而返回值和现实生活中的一些行为很类似。

### 参数

#### 什么是参数？

参数在函数里可以有也可以没有具体需不需要参数，由函数的内容决定。

**例子：**

我让你去买一杯奶茶，如果你有钱我就不需要给你钱去买，如果你没有钱我就需要给你钱去买，而这个钱在函数里面相当于参数而要不要给参数需要根据不同情况而定。

### 函数名

#### 什么是函数名？

函数名相当于要执行的指定任务里面的主要内容，当然你也可以随便取名但是在你使用的时候会容易分不清这个函数里面的内容，通常我们给函数取名都是根据他执行的任务有关的名字。

**例子：**

我要喝奶茶，我让你去买。

这个任务的主要内容是买奶茶，所以这个函数名我们会取成买奶茶而不是和任务内容无关的名字。

## 函数调用

### 什么是函数调用？

函数调用指的是你让那个函数去完成。

### 实参

#### 什么是实参？

实参是指你在调用它的时候给它的参数，而在这里的参数我们都称之为实参。

### 形参

#### 什么是形参？

形参指的是函数那接收的参数，而这个参数只是形式上的参数，实际上是不存在的，只有当你真的给它参数的时候才会存在。

### 传参

#### 什么是传参？

当实参把数据传给形参的时候，这个过程我们称之为传参。

#### 值传递

##### 什么是值传递？

值传递指的是实参传递的时候只传递它里面的内容，这个行为叫做值传递。

**例子：**

我有个盒子，我把盒子里面的东西给你看一下，然后你直接去买一个一摸一样的盒子里面的东西你也装的和我一样，而这个时候你想要有和我一样的盒子你也买了一个一摸一样的盒子盒子里面装的一摸一样的东西，而这个时候会有两个一摸一样的盒子，但是这个盒子里面装的虽然是同一个东西但你的盒子不是原装的，你对你盒子里面的东西随便改随便捣鼓都不会影响到我盒子里面的东西，因为这是两个盒子不是同一个盒子，虽然东西一样盒子的样子也一样，但不是同一个东西。

```c
#include <stdio.h>

void Swap(int a, int b)
{
    int temp = a;
    a = b;
    b = temp;
}

int main()
{
    int a = 100;
    int b = 3;

    printf("交换前：a:%d\tb:%d\n", a, b);

    Swap(a, b);

    printf("交换后：a:%d\tb:%d\n", a, b);

    return 0;
}

int add(int a, int b)
{
    int ret = a + b;

    return ret;
}
```

![image-20220108170034730](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220108170034730.png)



### 址传递

##### 什么是址传递？

址传递指的是我把我这个实参给你了，这个行为是址传递。

**例子：**

我有个盒子，我把这个盒子借你用，你是直接拿到我这个盒子，然后你把盒子里面的东西换了或者弄坏了，会影响到我因为我借你的东西我拿回来不一样了，因为我们两用的是同一个盒子所以会影响到我。

```c
#include <stdio.h>

void Swap(int* a, int* b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main()
{
    int a = 100;
    int b = 3;

    printf("交换前：a:%d\tb:%d\n", a, b);

    Swap(&a, &b);

    printf("交换后：a:%d\tb:%d\n", a, b);

    return 0;
}

int add(int a, int b)
{
    int ret = a + b;

    return ret;
}
```

![image-20220108170257154](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220108170257154.png)



## 库函数

### 什么是库函数？

库函数你可以想象成是一个工具箱，这个工具箱里面有很多工具你想要用某个工具你就去装这个工具的工具箱里面拿。

### 为什么要有库函数？

因为很多人都经常用到某个工具，但是这个工具没有工具箱而没有工具箱你这个工具就会消失，而一旦消失就要重做每次开发不同项目要重做之前的常用工具，这会导致效率很慢而且你的工具也容易出问题。

假设C标准委员会是设计图纸的人，而编译器的厂商是制作工具的人，C标准委员会看到打家经常用某个工具，C标准委员会决定定制这个工具的图纸（标准），而这个图纸（标准）一旦发布那么厂商（编译器的开发团队）就会按照这个图纸（标准）制作相关的工具并放到工具箱内，来供开发者使用这样开发者只需要去指定的工具箱里面拿工具，也不用担心自己做的工具会出问题，同时还节省了时间让开发者更专注的开发。

## 自定义函数

### 什么是自定义函数？

自定义函数就是指自己创建的函数，说人话就是你自己做的一个工具，这个工具不经常使用一般只有你一个人或极少数人用的到，所以你需要自己做一个这种工具。

## 函数的创建与调用

假设我们做个加法器工具，这个加法器只能进行简单的运算。

```c
#include <stdio.h>

int add(int a, int b)
{
    int ret = a + b;

    return ret;
}

int mian()
{
    int a = 10;
    int b = 20;

    int ret = add(a, b);

    printf("%d\n", ret);

    return 0;
}
```

![image-20220108165319468](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220108165319468.png)

## 函数的声明与定义

### 什么是函数的声明？

函数的声明是当编译器找不到该函数的定义的时候，对函数进行声明。因为编译器再进行编译的时候会对语法检查而它检查的方式是从上往下依次执行，当执行到调用函数的位置的时候还没看到过函数的定义，那么它会对此进行一个报错此`error`为：未找到定义的xxxx函数。

而函数声明的作用相当于提前跟编译器说如果你在看到这个函数名前没看到函数的定义的话请往下继续找，这个行为只是和编译器说了一声但是真的有没有不是你声明说的算，如果没有的话编译阶段不会报错但是调用阶段会报错此`error`为：链接错误。

**例子：**

编译器：这个函数我在前面没见过啊！

我：这个函数在后面你往后找就能找到了。

编译器：好，那我先给你编译通过。

链接ing……

**找不到的情况：**

编译器：你说后面有这个东西我也没找到啊！

编译器：`error`链接失败！

**找到的情况：**

编译器：我找到了！

编译器：链接成功，生成可执行程序！

---



**总结：** 一般在使用声明的时候，定义要么在函数调用后面要么就是在其它源文件内，为了编译通过会在该函数调用前和编译器说一声，而这个行为我们叫做声明。

### 什么是函数的定义？

函数的定义就是函数具体的实现细节，里面的实现细节我们称之为定义。

**例子：**

我们定义一个加法函数，不是说我们直接写个函数名和参数就能实现加法的，需要把实现的过程写在里面这就是实现方法也叫函数的定义。

## 函数递归

### 什么是函数递归？

函数递归指的是函数的定义里面有重复调用自己来完成某种特殊的任务，这种行为我们称之为递归。

类似大事化小，小事化了。把一个大型任务分解成诺干个小型任务再把若干个小型任务分解成微型任务直到任务无法再分解再交给自己完成。

相当于火影里面的鸣人能有很多个自己的分身让分身去完成不同的任务，这样就达到分解一个大型任务的效果，当然计算机使用这能力也是有代价的就是因为分裂的越多那么内存占用也就越大，效率也就降低了因为管一两个人很好管，如果管一个学校的所有学生不好管也没那个精力全都管到，如果硬要全都管到那么代价就是时间成本增高。

### 函数递归的必要条件

+ 条件一

  结束函数递归的条件，如果没有这个条件函数就会无休止的调用下去直至程序崩溃。

+ 条件二

  在函数每执行一次递归，函数和终止递归的条件距离就缩短一步。如果没有这个条件那么函数也会无休止的递归下去直到程序崩溃。

### 函数递归的优点与缺点

#### 优点

1. 一个复杂的任务，用递归来完成代变会变的非常简单
2. 代码量少

#### 缺点

1. 对于人来说任务变简单了，但是对于机器来说任务变的有很多不必要的重复，从而导致任务执行效率变低了。
2. 代码量少了，只是占用磁盘空间变小了，但是内存占用变大的了。
3. 由于一直分解导致有很多个自己在执行不同的任务，使得程序员推演代码的结果成本变高了，一旦出问题调式起来就是噩梦。

---



**总结：** 当你对程序效率没要求且这个程序用递归实现不会出问题，那么这个时候推荐用递归因为递归代码量少代码逻辑也不复杂，当用递归的结果会出问题或对效率有要求就使用循环，显然循环代码量大且代码逻辑会有点复杂但是是最优解不管是性能上还是其它方面。



# 🍿🍿🍿进制转换

## 十进制转其它进制

> 十进制可以转换成任意进制，不过它转不同进制的时候根据不同的进制使用不同的形式转换。

![image-20220113132108543](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220113132108543.png)

## 其它进制互转

其它进制不能直接互转需要先转为十进制再进行转换对应的进制。

![image-20220113132236673](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220113132236673.png)

### 其它进制转十进制

权重就是原数的每位数的位置，一般权重是从0开始个数是第一个权重但是是从0开始。

根据此公式就能用各种进制转换成十进制：位数×进制^权重

![image-20220113133457208](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220113133457208.png)

# 🍟🍟🍟存储形式

C语言变量的值存储是以二进制补码的形式存储的，而我们直接显示的值都会被转换成二进制，因为这样子编译的时候就不需要转换了提升了效率。

## 原码

我们直接转换的二进制叫做原码，而编译器内部用的不是原码而是补码。

直接转换成二进制，这个二进制就是原码。

> 十进制：5
>
> 二进制：0000 0000 0000 0000 0000 0000 0000 0101
>
> 原码：0000 0000 0000 0000 0000 0000 0000 0101

## 反码

原码按位取反就是反码。

> 十进制：5
>
> 二进制：0000 0000 0000 0000 0000 0000 0000 0101
>
> 反码：1111 1111 1111 1111 1111 1111 1111 1010



## 补码

反码+1就是补码

> 十进制：5
>
> 二进制：0000 0000 0000 0000 0000 0000 0000 0101
>
> 补码：1111 1111 1111 1111 1111 1111 1111 1011



# 🥞🥞🥞操作符

## 算术操作符

> \+ \- \* / %

+ %

  取余数不会除尽，只能进行整型之间的运算，如果对其它类型进行运算会报错。

+ /

  根据运算类型来确定结果类型，如果是混合运算会进行隐式类型转换（ps：小的会向大的转换，因为计算机的运算只能是相同类型计算），不能对非零进行÷否则机器会报错，因为设计是不能÷0。

## 位移操作符

###  左移操作符

+ `<<`

  > 二进制位向做移动n位
  >
  > **例子：**
  >
  > `5 << 3`
  >
  > 5向左移3位低位补零，右操作数不能是负数。
  >
  > 十进制：5
  >
  > 二进制：0000 0000 0000 0000 0000 0000 0000 0101
  >
  > 二进制向左移动3位：0000 0000 0000 0000 0000 0000 0010 1000
  >
  > 十进制向左移动3位：40
  >
  > **特点：** 向左移移动2的结果是原数×2的结果

+ `>>`

  > 二进制位向有移动n位
  >
  > **例子：**
  >
  > `-5 >> 3`
  >
  > -5向右移动3位，右操作数不能为0。
  >
  > 十进制：-5
  >
  > 二进制：1000 0000 0000 0000 0000 0000 0000 0101
  >
  > **算术右移：** 高位补符号位
  >
  > 二进制向右移动3位：1110 0000 0000 0000 0000 0000 0000 0000
  >
  > 十进制向右移动3位：3,758,096,384
  >
  > **逻辑右移：** 高位补零
  >
  > 二进制向右移动3位：0001 0000 0000 0000 0000 0000 0000 0000
  >
  > 十进制向右移动3位：268,435,456
  >
  > **特点：** 向右移动2位的结果是原数×2的结果

**总结：** 左移操作符向左移动2位相当于×2，而右移操作符向右移动2位相当于÷2，而使用位移操作符替代除2或乘2会比使用不替代的高效，因为cpu没有除法器和乘法器，它只有加法器大部分运算都是通过加法器加出来的（ps：部分cpu有减法器），而位移操作符是直接移动二进制位不需要相加所以比加法器做出来的乘法或除法效率要高因为执行次数很少。



## 位操作符

### 按位与

+ &

  > 左操作数和右操作数进行运算，二进制`&`不会不对两端操作数进行数值改变，但是会有一个通过两端操作数按位与出来的结果。
  >
  > **例子：**
  >
  > `1 & 2`
  >
  > 左操作数：0000 0000 0000 0000 0000 0000 0000 0001
  >
  > 右操作数：0000 0000 0000 0000 0000 0000 0000 0010
  >
  > 按位与结果：0000 0000 0000 0000 0000 0000 0000 0000
  >
  > **特点：** 两端操作数的二进制位有一个位假，那么该结果位置的二进制也会假

+ |

  > 左操作数和右操作数进行运算，二进制`|`不会对两端操作数进行数值改变，但是会有一个通过两端操作数按位或出来的结果。
  >
  > **例子：**
  >
  > `1 | 2`
  >
  > 左操作数：0000 0000 0000 0000 0000 0000 0000 0001
  >
  > 右操作数：0000 0000 0000 0000 0000 0000 0000 0010
  >
  > 按位或结果：0000 0000 0000 0000 0000 0000 0000 0011
  >
  > **特点：** 两端操作数的二进制位有一个为真，那么该结果位置的二进制位也为真。

+ ^

  > 左操作数和右操作数进行运算，二进制`^`不会对两端操作数进行数值改变，但是会有一个通过两端操作数按位异或出来的结果。
  >
  > **例子：**
  >
  > `1 ^ 2`
  >
  > 左操作数：0000 0000 0000 0000 0000 0000 0000 0001
  >
  > 右操作数：0000 0000 0000 0000 0000 0000 0000 0010
  >
  > 按位异或结果：0000 0000 0000 0000 0000 0000 0000 0011
  >
  > **特点：** 两端的二进制操作数相同，那么结果的该位置就为假，反之为真。

  

## 赋值操作符

+ =

  > 赋值操作符用于把右端的操作数表达式结果给左端操作数。

## 复合赋值操作符

> +=
>
> -=
>
> \*=
>
> /=
>
> %=
>
> \>>=
>
> <<=
>
> &=
>
> |=
>
> ^=

```c
int x = 10;
x = x+10;
x += 10;//复合赋值
//其他运算符一样的道理。这样写更加简洁
```

## 单目操作符

+ !

  > 逻辑反操作符，逻辑非。
  >
  > **特点：** 如果该表达式为真，那么用逻辑非就是假，反之为真。

+ -

  > 负号
  >
  > **特点：** 用于表示表达式是负数

+ +

  > 正号
  >
  > **特点：** 用于表示表达式是整数，默认情况不加就是正数

+ &

  > 取地址操作符
  >
  > **特点：** 用于取出变量的地址

+ sizeof

  > 计算变量或者类型的大小
  >
  > **特点：** 如果计算的是一个数组那么数组名就是计算整个数组的大小，计算各种类型所占字节根据不同平台所计算的大小也不同，在sizoef里面进行运算的表达式不会改变其值，因为运算是在编译的阶段进行计算，而`sizeof`是在执行阶段才进行计算所以在`sizeof`里面的运算不会生效。
  >
  > **三种使用方式：**
  >
  > 可以对变量和类型名进行计算大小，如果是变量名可以不用加（）也能计算
  > **如：**
  >
  > ```c
  > int a = 0;
  > sizeof a;
  > sizeof(a);
  > sizeof(int);
  > ```

+ ~

  > 按位取反
  >
  > **特点：** 按二进制位取反
  >
  > **例子：**
  >
  > `~1`
  >
  > 二进制：0000 0000 0000 0000 0000 0000 0000 0001
  >
  > 取反后：1111 1111 1111 1111 1111 1111 1111 1110
  >
  > 十进制：4294967294

+ --

  > 自减运算符
  >
  > 前置`--`：`--`后立即生效
  >
  > 后置`--`：`--`后不立即 生效，此条语句结束才生效。
  >
  > **特点：** 自减1，后置比前置优先级要高，且结合性也不同。

+ ++

  > 自增运算符
  >
  > 前置`++`：`++`后立即生效
  >
  > 后置`++`：`++`后不立即生效，此条语句结束后才生效。
  >
  > **特点：** 自增1，后置比前置优先级要搞，且结合性也不同。

+ \*

  > 间接访问操作符（解引用操作符）
  >
  > **特点：** 用于拿到指针变量存储地址类的数据。

+ (类型)

  > 强制类型转换
  >
  > **特点：** 强制性的改变一个类型的类型，但不会改变二进制的值只是改变类型的表示方式。

## 关系运算符

> \>
>
> \<
>
> \>=
>
> \<=
>
> ==
>
> !=

## 逻辑操作符

+ ||

  > 逻辑或
  >
  > **特点：** 只要有一个表达式为真那么结果就为真
  >
  > **短路运算：** 一旦一个表达式为真，那么后续的表达式的值不会进行计算直接结束。

+ &&

  > 逻辑与
  >
  > **特点：** 只要有一个表达式为假那么结果就为假
  >
  > **短路运算：** 只一旦一个表达式的为假，那么后续的表达式的值不会进行过计算直接结束。



## 条件操作符

+ :?

  > 三目操作符
  >
  > 可以理解成青春版`if`语句
  >
  > **例子：**
  >
  > 表达式1:表达式2?表达式3
  >
  > 如果表达式为真那么久执行表达式2作为结果，反之表达式3作为结果。



## 逗号表达式

> （表达式1，表达式2，表达式3，……，表达式4）；
>
> **特点：** 逗号表达式内进行的运算都会生效，不过该表达式的结果以最后一个逗号为该表达式的结果。



## 下标引用、函数调用和结构成员

### 下标引用

> `[]`
>
> 用于访问数组内的数据，而`[]`的操作数只有两个分别是：数组名和下标值。



### 函数调用

> 函数名()
>
> 用于调用函数，函数调用操作符的操作数分别是：函数名+参数。



### 结构体成员

+ 结构体`.`成员

  > 用于访问结构体内的成员

+ 结构体指针变量`->`成员名

  > 用于访问结构体指针的结构体成员。



## 表达式求值

> 表达式的求值顺序是根据操作符的优先级和结合性决定的。

## 隐式类型转换

> C语言再进行算术运算的时候如果运算数据类型不相同，C语言总是会以较大的类型为整个表达式运算的类型，较小值类型会被隐式类型转换成较大类型。

### 整型提升

> 整型及以下的类型才会发生整型提升，如果两个类型不同小的类型会被整型提升成较大的类型来进行计算，表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。
>
> 因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。
>
> 通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。
>
> 所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。

```c
int a = 10;
char b = 10;
char c = 20;
c = a + b;//此处b会被整型提升提升至和a一样，而由于c的类型存储不下整个结果所以会发生截断
```

#### 如何进行整型提升

> 整型提升后高位补的是当前类型的符号位，如果是无符号位那么整型提升的高位是零，而不是根据符号位来提升。

```c
//负数的整形提升
char c1 = -1;
变量c1的二进制位(补码)中只有8个比特位：
1111111
因为 char 为有符号的 char
所以整形提升的时候，高位补充符号位，即为1
提升之后的结果是：
11111111111111111111111111111111
//正数的整形提升
char c2 = 1;
变量c2的二进制位(补码)中只有8个比特位：
00000001
因为 char 为有符号的 char
所以整形提升的时候，高位补充符号位，即为0
提升之后的结果是：
00000000000000000000000000000001
//无符号整形提升，高位补0
```

**注意：** ==整型以下的类型只要是参与计算任务就会发生整型提升。==



### 算数转换

> 如果操作符的操作数都属于不同类型的运算，那么会进行**寻常算术转换**。

```c
long double
double
float
unsigned long int long int
unsigned int
int
```

如果操作数的排名在这个列表中较低那么它会进行隐式类型转换，把排名的操作数转换成较高排名的操作数。

**注意：** 如果转换不合理会出现一些潜在问题。



# 🍜🍜🍜指针

## 什么是指针？

> 指针和地址是同一个东西，为什么要有指针（地址）？
>
> 因为计算器要进行数据传输的时候需要把数据存放到一个地方，而存放到该位置你必须得有地址吧？不然你下次回来找这数据怎么找？或者让别人来找的时候如何找？如果是所有地方都找一遍的话，那样效率太低了。
>
> 为了提高效率就有了地址的概念，地址本身是不用拿空间记录的，因为地址的编址是根据物理内存的地址线来生成的，物理地址线只有32根且电信号脉冲只有0（无脉冲）和1（有脉冲）这两种信号状态。
>
> 所以，我们可以算出该物理地址能表示的只有 $$ 2^{32} $$ 种状态，那么地址也只能编址出$$ 2^{32} $$ 个地址。
>
> 当有了地址那么数据的存取也将变的非常高效，只要我们有这个数据的地址那么我们就能随便对它进行读写（前提是这地址空间属于你）。

### 为什么是二进制？

> 因为指针（地址）是一个电信号脉冲，而电信号脉冲只有两种状态，所以计算机就只能表示二进制且也只认识二进制，这也是为什么不管任何语言都要转换成机器码的原因。

#### 物理内存

> 你去看内存条的话，你会发现内存条不管是DDR2、DDR3、DDR4和DDR5的布局都是一边长一边短的，而不同厂商的分配可能不同，可能是混合使用，也可能是长边是总线，短边是数据+控制总线。

**内存条展示图：**

DDR3内存条：

![image-20220211084242548](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220211084242548.png)

DDR5内存条：

![image-20220211084306771](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220211084306771.png)

![image-20220211084329488](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220211084329488.png)

**物理地址布局图：**

![image-20220211083004668](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220211083004668.png)

## 指针变量

> 指针变量就是用于保存地址的变量，每个变量都有地址对应的虚拟地址空间，而且是唯一标识相当于门牌号而里面存放的东西就是值。

## 不同类型的指针变量有什么区别

每种指针变量能访问的权限都不一样如果想要访问的内容不一样，那么我们可以使用不同类型的指针变量，来进行读和写。

不同类型的指针变量每次自增1的跨度也不一样，具体跨度是由指针变量来决定的。



## 野指针

### 野指针的定义

野指针是由于指针变量指向了没有使用权的地址和未初始化，这些指针变量都称之为是野指针。

### 野指针的生成

1. 未初始化的指针变量
2. 指向的空间已释放
3. 指向了其它人的地址空间

### 如何避免生成野指针

1. 对每个指针变量初始化，如果没想好初始化建议给`NULL`，`NULL`是空指针而底层是0.
2. 指向的空间被释放时要对该指针进行置空
3. 避免指向不属于自己的地址

## 指针的运算

### 指针的+-运算

#### 指针-指针

指针相减得到的绝对值是元素个数-1

#### 规定

**C语言标准规定：** 指针访问越界不能向前越界只允许向后越界。

## 多级指针

指针变量也是由地址的当我们想要对该指针变量要进行保存的话，那么我们需要比该指针高一级的指针来存储，而指针每多一级会多一个`*`，我们可以通过此操作符来进行来对该指针变量进行判断是几级指针。一个`*`就是一级而每个高级指针都有自己的地址，而多级指针没有上限理论上来讲只要你愿意就可以拥有N级指针但是正常来讲我们用最多的也就是二级指针，而更高级的指针我们几乎很少用到。

## 指针数组

> 指针数组本质是一个数组，而这个数组存储的是指针变量所以叫指针数组。

![image-20220121150700884](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220121150700884.png)

### 指针数组的创建

```c
int a = 20;
int* p1 = &a;
int* arr[4] = { 0 };//每个元素都是一个int*如果没有*就是整型数组，本质是一个数组不过是存储的类型不同

arr[0] = p1;

printf("%d", *(*arr));//对第一个元素解引用，由于第一个元素是int*类型所以还需要进行解引用得到a的值
```

![image-20220121151132123](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220121151132123.png)



## 数组指针

用于指向数组的指针，该指针存储的类型是一个数组类型。

一般是用于存储二维数组，传参时用的居多。

### 数组指针的创建

```c
	int arr[3][4] = { 0 };
	int i = 0;
	int j = 0;

	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 4; j++)
		{
			arr[i][j] = i + j;
		}
	}

	int(*p1)[4] = arr;//这里的元素个数指的是一维数组的元素，p1先和*结合说明它是一个指针，而它的指针类型是int[]是一个整型数组。

	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 4; j++)
		{
			printf("%d ", *(*(p1 + i) + j));
		}

		printf("\n");
	}
```

![image-20220121155322523](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220121155322523.png)

![image-20220121155302402](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220121155302402.png)



### 数组指针指向一维数组

一般不会这么用因为指向一维数组的方式看起来很怪。

```c
	int arr2[3] = { 1, 2, 3 };
	int(*p2)[3] = &arr2;//取整个数组的地址，让指针指向，而指针也只能指向3个元素的整型数组。

	for (i = 0; i < 3; i++)
	{
		printf("%d ", *((*p2) + i));//直接对p2解引用取到arr2的首元素地址，对该地址+i再解引用取到的是该位置的元素
	}
```

![image-20220121160158030](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220121160158030.png)



### 如何分辨指针数组和数组指针？

我们可以先通过，变量名和那个操作符先结合。

如果变量名先和`[]`结合说明该变量是数组，且前面有`*`操作符说明该变量类型是指针数组。

如果变量名先和`*`结合且后面有`[]`说明该指针变量的类型是一个数组指针。

**总结：** <font color="#06caa">根据末尾两个字来判断该变量类型本质是指针还是数组。</font>



## 函数指针

每个函数都有相应的地址，那么自然也有指向函数地址类型的指针，每个函数名就是地址和数组一样名字可以充当地址，也可以取地址。

### 创建

```c
int Add(int a, intt b)
{
	return a + b;
}

int main()
{
	int (*p1)(int, int) = &Add;//函数指针指向一个函数指针地址
	int (*p1)(int, int) = Add;//函数指针此操作和上面的操作等价

	int ret = (*p1)(30, 40);//等价于直接调用Add函数
	int ret = (*****p1)(30, 40);//等价于直接调用Add函数//有没有*都无所谓，即使没有可以，有*是方便我们理解。
    int ret = (p1)(30, 40);//这几种写法都可以，都是等价的。
    
	return 0;
}
```

### 函数指针取别名

C语言规定，typora给函数指针取别名的时候别名必须放在括号内，而不是最右边正常的类型取别名都是定义在后面的，但是函数指针不同。

### 创建

```c
#include <stdio.h>

int Add(int a, int b)
{
	return a + b;
}

typedef int(*pf)(int, int);//类型重定义

int main()
{
	pf p1 = Add;//函数指针类型创建初始化

	printf("%d",(*p1)(30, 40));	//解引用函数指针调用该函数

	return 0;
}
```



## 函数指针数组

函数指针数组本质是一个数组，不过它存放的类型是函数指针类型。

### 创建

```c
#include <stdio.h>

int Add(int a, int b)
{
	return a + b;
}

int Sub(int a, int b)
{
	return a + b;
}

int main()
{

	int (*arr[2])(int, int) = { Add, Sub };//如果怕写不出来，就先写成函数指针，然后再函数指针的变量名后面+[元素个数]就成了函数指针数组

	printf("%d %d", (*(arr[0]))(20, 10), (*arr[1])(40, 80));//函数指针数组的调用

	return 0;
}
```

## 函数指针数组指针

用于指向函数指针数组类型的指针。

### 创建

```c
#include <stdio.h>

int Add(int a, int b)
{
	return a + b;
}

int Sub(int a, int b)
{
	return a - b;
}

int main()
{
	int (*arr[2])(int, int) = { Add, Sub };//函数指针数组
	int (*(*p1)[2])(int, int) = &arr;//函数指针数组指针

	printf("%d %d", (*(*p1)[0])(30, 40), (*(*p1)[1])(50, 20));//使用函数指针数组指针

	return 0;
}
```

## 回调函数

> 回调函数就是一个通过函数指针调用的函数，如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。
>
> 回调函数不是由该函数的实现方直接调用，而是在特定的时间或条件发生时由另外的一方调用，用于对该事件或条件进行响应。

### 回调函数的使用

```c
#include <stdio.h>

int Add(int a, int b)
{
	return a + b;
}

int test(int (*pa)(int, int))
{
	return pa(30, 40);//回调函数，通过在该函数被动调用其它函数
}

int main()
{
	printf("%d",test(Add));//传要被调用的函数地址即可完成回调函数

	return 0;
}
```



# 断言

括号内的表达式为真什么事都不会发生，如果为假则会报错。



# 🥠🥠🥠结构体

结构体是由多种不同的基础类型构成的一种新类型，该类型叫做结构体。

## 结构体的创建

结构体变量支持是任何类型，可以是其它结构体类型。

**结构体组成：** `struct name` {结构体成员};

```c
struct students
{
    char[20] name;
    short age;
    short id;
    char[4] sex;
};

struct students
{
    char[20] name;
    short age;
    short id;
    char[4] sex;
}s1, s2;//全局变量

struct students s3;//全局变量

int mian()
{
    struct students s4;//局部变量
    
    return 0;
}
```



## 结构体的初始化

```c
struct students
{
    char[20] name;
    short age;
    short id;
    char[4] sex;
};

int mian()
{
    struct students s1 = { "李四", 12, 2002, "男" };
    
    return 0;
}
```



## 结构体传参

+ 结构体值传递

  空间占用大需要拷贝，因为传参的时候需要压栈而结构体过大的话，系统压栈开销较大会导致性能降低。

+ 结构体址传递

  空间占用小无拷贝



# 💥💥💥数据的存储

## 类型的意义

> 类型的不同表示它们的存储结构与存储大小不同，如果每个类型都相同的话那么类型就没有意义了。
>
> 本质对内存进行合理划分，按需所取，类型为什么在C中有这么多种：应用场景不同，解决不同应用场景得计算方式，需要空间的大小也是不同的。
>
> 本质：用最小的成本解决各种多样化的场景问题。

## 正整数

正整数的原码、反码、补码都相同，一般直接翻译成二进制就是该整型在内存中的实际存储。

## 负整数

负整数的原码、反码、补码都补相同，且实际内存中存储的是补码，而我们一般都只会翻译成原码。

## 为什么是补码？

> 在计算机系统中，数值一律用补码来表示和存储，原因在于，使用补码，可以将符号位和数值域统一处理，同时，加法和减法也可以统一处理（CPU只有加法器）此外，补码与原码互相转换，其运算过程是相同的，不需要额外的硬件电路。

## 十六进制存储序列

十六进制序列默认是左低右高，而十六进制默认是左高右低。

![image-20220120203759902](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220120203759902.png)

### 大端字节序

低地址在十六进制序列的高地址位，低地址位在十六进制序列的高地址位。

![image-20220121145648340](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220121145648340.png)

### 小端字节序

低地址在十六进制序列的高地址位，低地址位在十六进制序列的高地址位。

![image-20220121145629126](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220121145629126.png)

### 为什么会有大小端之分？

> ​	这是因为在计算机系统中，我们是以字节为单位的，每个地质单元都对应着一个字节，一个字节为`8Bit`，但是在C语言中除了`8Bit`的char之外，还有`16Bit`的short型，`32bit`的long型（要看具体编译器）另外，队友位数大于8位的处理器，例如：16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题，因此就导致了大端存储模式和小端储存模式。
>
> ​	例如：`16bit`的short型x，在内存中的地址为`0x0010`，x的值为`0x1122`，那么`0x11`为高字节，`0x22`为低字节，对于大端模式就将`0x11`存放在低地址中，即`0x0010`中，`0x22`存放在高地址中，即`0x0011`中，小端模式，刚好相反。
> ​	我们常用的x86结构是小端模式，而`KELIL C51`则为大端模式，很多ARM，DSP都为小端模式。
> ​	有些ARM处理器还可以由硬件来选择大端模式还是小端模式。

### 大小端顺口溜

> 小（低字节序）小（低权值）小（小端），如果不是小小小就说明是大端。

### 面试题：设计判断机器大小端的程序

```c
#include <stdio.h>

//返回真是小端
//返回假是大端
int CheckSys()
{
	int x = 1;

	return (*(char*)&x);
}

int main()
{
	if (CheckSys())
	{
		printf("小端\n");
	}
	else
	{
		printf("d端\n");
	}

	return 0;
}
```

### 截断

> 当一个变量的类型存储不下二进制数据时就会发生截断，只保留该类型能表示的最大数据，抛弃的部分通常时高位二进制数据。

# 🎫🎫🎫枚举

> 枚举类型是一种列举类型常量，它本质是一个常量默认给值是从0开始依次往后递增1。

### 定义

```c
//默认给值是0依次递增，如果第一个没给值，而中间的给一个值，最后没给值，那么最后的值是前面的值+1
enum RGB
{
	RED,
	GREEN,
	BLUE
};
```

### 特点

> 1. 增加代码的可读性和可维护性
> 2. 和#define定义的标识符比较枚举有类型检查，更加严谨。
> 3. 防止了命名污染（封装）
> 4. 便于调试
> 5. 使用方便，一次可以定多个常量。



# 🛒🛒🛒动态内存管理

### 为什么存在内存分配？

> 因为我们C语言需要一种按需分配空间大小的工具，而平常的静态不能满足我们的使用需求，因为静态的给的数值是固定的一旦生成可执行程序就无法修改，给小了程序会出问题而给大了会造成空间浪费。
>
> 而动态内存分配可以根据需求来进行开辟空间和使用空间不会过大也不会不能增长。

### malloc

> `malloc`函数是向系统申请一块连续可用的指定大小的空间，如果系统没有空间或者申请的空间过大会导致申请失败。
>
> **返回值：** 申请成功会返回一个地址，申请失败会返回一个空指针
>
> **函数原型：**
>
> ```c
> void *malloc( size_t size );
> ```

**使用案列：**

```c
void test1()
{
	//向系统的堆中申请10个整型大小的空间
	int* p1 = (int*)malloc(sizeof(int) * 10);

	//检查内粗是否申请成功
	if (!p1)
	{
		printf("内存申请失败\n");

		exit(-1);
	}

	int i = 0;

	for (i = 0; i < 10; i++)
	{
		p1[i] = i;
	}

	for (i = 0; i < 10; i++)
	{
		printf("%d ", p1[i]);
	}
    
    free(p1);
    p1 = NULL;

}
```

calloc

> `calloc`和`malloc`一样不过唯一区别是，`calloc`会对申请的空间初始化成1.
>
> 参数1：申请大小的个数
>
> 参数2：申请大小的类型
>
> **函数原型：**
>
> ```c
> void *calloc( size_t num, size_t size );
> ```

**使用案例：**

```c
void test2()
{
	//向系统的堆中申请10个大小并初始化成0，而参数1是申请个数，参数2是申请的个数大小：10 * sizeof(int) == 10, sizeof(int)
	int* p1 = (int*)calloc(10, sizeof(int));

	//检查内粗是否申请成功
	if (!p1)
	{
		printf("内存申请失败\n");

		exit(-1);
	}

	int i = 0;


	for (i = 0; i < 10; i++)
	{
		printf("%d ", p1[i]);
	}
}
```

### realloc

> `realloc`是把一个已有空间扩容，如果后面又足够的空间就会原地扩容，后面的空间不够就会在另一块足够的空间开辟一个新空间并把旧空间的数据拷贝到新空间同时销毁旧空间。
>
> 参数1：要扩容的空间
>
> 参数2：扩容大小
>
> **返回值：** 申请成功会返回一个地址，该地址可能是原来的空间也可能是新的地址空间，申请失败会返回一个空指针。

**使用案列：**

```c
void test3()
{
	int* p1 = (int*)malloc(sizeof(int) * 10);
	if (!p1)
	{
		printf("申请空间失败\n");
		exit(-1);
	}
	
	//用一个临时变量来存储，即使开辟失败也不会影响原有的空间
	int* temp = (int*)realloc(p1, sizeof(int) * 20);
	if (!temp)
	{
		printf("内存申请失败！\n");

		exit(-1);
	}

	p1 = temp;

	int i = 0;

	for (i = 0; i < 20; i++)
	{
		p1[i] = i;
	}

	for (i = 0; i < 20; i++)
	{
		printf("%d ", p1[i]);
	}
}
```

**总结：** 任何一处的内存申请都需要进行判断是否成功申请，否则会造成空指针访问。

### free

> 释放用户向堆上申请的空间，因为在堆上申请的空间只有两种情况才会释放。
>
> 1. free释放
> 2. 程序结束自动释放所有资源

**使用案列：**

```c
void test4()
{
	int* p1 = (int*)malloc(sizeof(int) * 10);
	if (!p1)
	{
		printf("申请空间失败\n");
		exit(-1);
	}

	//用一个临时变量来存储，即使开辟失败也不会影响原有的空间
	int* temp = (int*)realloc(p1, sizeof(int) * 20);
	if (!temp)
	{
		printf("内存申请失败！\n");

		exit(-1);
	}

	p1 = temp;
	temp = NULL;

	int i = 0;

	for (i = 0; i < 20; i++)
	{
		p1[i] = i;
	}

	for (i = 0; i < 20; i++)
	{
		printf("%d ", p1[i]);
	}

	free(p1);
	p1 = NULL;
}
```

#### free注意事项

> 1. 在释放一块空间地址的时候一定要确认它是否还属于你，如果不属于你申请的空间那么会造成越界访问。
> 2. 释放掉该地址时应把该指针置空，以防止后续的失误操作进行越界访问。

### 内存申请的常见问题

> 1. 传空指针
> 2. 内存空间不够
> 3. 对空指针进行解引用
> 4. 对动态空间越界访问
> 5. 释放空指针
> 6. 释放不属于自己的空间地址或多次释放同一个空间地址

#### 内存泄漏

> 内存泄漏指的是无非再利用所以内存就像水一样泄漏了，一般只要不乱丢地址或不释放地址都不会发生内存泄漏的。

##### 内存泄漏的危害

> 内存泄漏一般会造成内存越用越少直到宕机，如果不好好使用指针那么这个问题是很难排查的特别是大项目。



### 系统内存布局图

![image-20220128202542690](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220128202542690.png)

# 🎨🎨🎨文件操作

### 什么是文件？

> 磁盘上存储的数据都是文件

#### 程序文件

> 程序文件（后缀.c），目标文件（windows环境后缀位.obj），可执行程序（windows环境后缀位.exe）。

#### 数据文件

> 文件的内容不一定是程序，而是程序运行时读写的数，比如程序运行需要从中读取数据的文件，或者输出内容的文件。

#### 文件名

> 一个文件要有一个唯一的文件标识，以便用户识别和引用。
> 文件名包含三部分：文件路径+文件名主干+文件后缀
> **例如：**`C：\code\test.txt`

### 文件的打开与关闭

#### 文件指针

> 　缓冲文件系统中，关键的概念是”**文件类型指针“，**简称**“文件指针”
> **每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件的名字，文件状态及文件当前的位置等）。这些信息是保存在一个结构体变量中的。该结构体类型是由系统声明的，取名为：**FILE**

#### fopen

> 打开一个文件，参数1文件名，参数2打开文件的方式。
>
> **返回值：** 如果打开成功会返回改文件的地址，如果失败会返回一个空指针，在使用此函数的时候要对指针进行判断防止对空指针的访问。
>
> **函数原型：**
>
> ```c
> FILE *fopen( const char *filename, const char *mode );
> ```
>
> **使用列子：**
>
> ```c
> #include <stdio.h>
> #include <errno.h>
> #include <string.h>
> 
> int main()
> {
> 	FILE* pf = fopen("data.txt", "w");
> 	if (!pf)//检查是否打开，如果没打开就会返回空指针从而进行报错
> 	{
> 		printf("%s\n", strerror(errno));
> 
> 		return 1;
> 	}
> 
> 	return 0;
> }
> ```

##### 打开方式

| 文件使用方式 |                   含义                   | 如果指定文件不存在 |
| :----------: | :--------------------------------------: | :----------------: |
|  r（只读）   | 为了输入数据，打开一个已经存在的文本文件 |        出错        |
|  w（只写）   |      为了输出数据，打开一个文本文件      |   创建一个新文件   |
|  a（追加）   |           向文本文件尾添加数据           |        出错        |
|  rb（只读）  |   为了输入一个数据，打开一个二进制文件   |        出错        |
|  wb（只写）  |   为了输出一个数据，打开一个二进制文件   |   创建一个新文件   |
|  ab（追加）  |       向一个二进制文件尾部添加数据       |        出错        |
|  r+（读写）  |       为了读和写，打开一个文本文件       |        出错        |
|  w+（读写）  |       为了读和写，打开一个文本文件       |  创建一个新的文件  |
|  a+（读写）  |     打开一个文件，在文件尾部进行读写     |  创建一个新的文件  |
| rb+（读写）  |  为了读和写，新建一个新的二进制文本文件  |  创建一个新的文件  |
| wb+（读写）  | 为了读和写，新建一个新的二进制在文本文件 |  创建一个新的文件  |
| ab+（读写）  |  打开一个二进制文件，在文件尾部进行读写  |  创建一个新的文件  |

#### fclose

> 当一个文件被打开，我们不需要使用的时候一定要关闭，该文件被关闭之后你的指针指向的地址就是一个非法地址，如果不进行置空一旦该指针被人使用那么就会造成越界访问。
>
> **返回值：** 如果关闭成功会返回一个零，如果关闭失败会返回一个`EOF`。
>
> **函数原型：**
>
> ```c
> int fclose( FILE *stream );
> ```
>
>  **使用案列：** 
>
> ```c
> #include <stdio.h>
> #include <errno.h>
> #include <string.h>
> 
> 
> int main()
> {
> 	//打开文件
> 	FILE* pf = fopen("data.txt", "w");
> 	if (!pf)
> 	{
> 		printf("%s\n", strerror(errno));
> 
> 		return 1;
> 	}
> 
> 	fclose(pf);
> 	pf = NULL;//置空防止被误操作造成越界访问。
> 
> 	return 0;
> }
> ```



### 文件顺序读写

#### 输入流

|      功能      | 函数名 |  使用场景  |
| :------------: | :----: | :--------: |
|  字符输入函数  | fgetc  | 所有输入流 |
| 文本行输入函数 | fgets  | 所有输入流 |
| 格式化输入函数 | fscanf | 所有输入流 |
|   二进制输入   | fread  |    文件    |

##### fgetc

> 把文本数据的内容像水一样流向某个变量内，而该函数的参数只有一个源头（ps：指水的源头），返回值最为流向所以需要一个变量来接收。
>
> **返回值：** 返回读取到的数据，如果读取失败会返回一个`EOF`
>
> **函数原型：**
>
> ```c
> int fgetc( FILE *stream );
> ```
>
> **使用案列：**
>
> ```c
> #define  _CRT_SECURE_NO_WARNINGS
> #include <stdio.h>
> #include <errno.h>
> #include <string.h>
> 
> int main()
> {
> 	//打开文件
> 	FILE* pf = fopen("data.txt", "r");
> 	if (!pf)
> 	{
> 		printf("%s\n", strerror(errno));
> 
> 		return 1;
> 	}
> 
> 	int ch = 0;
> 
> 	ch = fgetc(pf);
> 
> 	//读取一个字符
> 	printf("%c\n", ch);
> 
> 	//每次读取单个字符直到读取完或者读取指定个数的字符
> 	while (~(ch = fgetc(pf)))
> 	{
> 		printf("%c", ch);
> 	}
> 
> 	//从输入流内读取一个，也可以使用循环改成多次读取标准输入流内的数据
> 	ch = fgetc(stdin);
> 	printf("%c", ch);
> 
> 	fclose(pf);//关闭文件
> 	pf = NULL;//置空防止被误操作造成越界访问。
> 
> 	return 0;
> }
> ```

##### fgets

> **函数原型：**
>
> ```c
> char *fgets( char *string, int n, FILE *stream );
> ```
>
> **参数1：** `string`用于存放读取的数据
>
> **参数2：** `n`用于指定读取数据的个数，n小于文件数据的内容那么`string`只会存放`n - 1`个有效数据`n`的位置存储`\0`，n大于文件数据文本数据读取完了，如果文本数据内有换行那么也会读进来，后面的数据都会用来默认存放`\0`。
>
> **参数3：** 读取的源头（ps：说人话就是你要告诉它去那个地方读取，可以从所有的输入流读取）
>
> **返回值：** 读取失败或错误返回`NULL`，读取成功返回读取到的字符串的首地址。
>
> **使用案列：**
>
> ```c
> #define  _CRT_SECURE_NO_WARNINGS
> #include <stdio.h>
> #include <errno.h>
> #include <string.h>
> 
> int main()
> {
> 	//打开文件
> 	FILE* pf = fopen("data.txt", "r");
> 	if (!pf)
> 	{
> 		printf("%s\n", strerror(errno));
> 
> 		return 1;
> 	}
> 
> 	char str[20] = { 0 };
> 	char* pstr = 0;
> 
> 	pstr = fgets(str, 8, pf);
> 	if (feof(pf))//判断是否因为读取完整个数据流造成的问题
> 	{
> 		printf("数据已读完，读取失败！\n");
> 	}
> 	printf("%s\n%s", str, pstr);
> 
> 	fclose(pf);//关闭文件
> 	pf = NULL;//置空防止被误操作造成越界访问。
> 
> 	return 0;
> }
> ```

#### fscanf

> **函数原型：**
>
> ```c
> int fscanf( FILE *stream, const char *format [, argument ]... );
> ```
>
> **参数一：** 从那个文件内读取数据
>
> **参数二：** 接收数据的格式
>
> **参数三：** 用于接收数据的变量，可以是多个数据
>
> **返回值：** 如果成功，该函数返回成功匹配和赋值的个数，如果文件到达末尾或发生读错误，则返回`EOF`
>
> **例子：**
>
> ```c
> #define  _CRT_SECURE_NO_WARNINGS
> #include <stdio.h>
> #include <errno.h>
> #include <string.h>
> 
> typedef struct stu
> {
> 	char name[20];
> 	int age;
> 	float score;
> }stu;
> 
> int main()
> {
> 	stu s1 = { 0 };
> 	FILE* fp = fopen("data.txt", "r");
> 	if (!fp)
> 	{
> 		printf("%s\n", strerror(errno));
> 
> 		return 1;
> 	}
> 
> 	fscanf(fp, "%s %d %f", s1.name, &(s1.age), &(s1.score));
> 	if (ferror(fp))
> 	{
> 		printf("数据已读完，读取错误！\n");
> 	}
> 
> 	printf("%s\t%d\t%.2f\n", s1.name, s1.age, s1.score);
> 
> 	return 0;
> }
> ```

#### fread

> **函数原型：**
>
> ```c
> size_t fread( void *buffer, size_t size, size_t count, FILE *stream );
> ```
>
> **参数一：** 读取的内容存放位置
>
> **参数二：** 该存放位置的大小
>
> **参数三：** 读取个数
>
> **参数四：** 读取源文件
>
> **返回值：** 如果读取成功且没到文件结尾，那么会返回和**参数三** 相同的值，如果遇到文件结尾结束那么返回的值可能会小于 **参数三** ， 如果 **参数二和参数三为零** 那么返回值就是0.
>
> **使用例子：**
>
> ```c
> #define  _CRT_SECURE_NO_WARNINGS
> #include <stdio.h>
> #include <errno.h>
> #include <string.h>
> 
> typedef struct stu
> {
> 	char name[20];
> 	int age;
> 	float score;
> }stu;
> 
> int main()
> {
> 	stu s1 = { 0 };
> 	FILE* pf = fopen("dataB.txt", "rb");
> 	if (!pf)
> 	{
> 		printf("%s\n", strerror(errno));
> 
> 		return 1;
> 	}
> 
> 	//读取二进制文件存放到s1里
> 	fread(&s1, sizeof(s1), 1, pf);
> 
> 	//确认是否存放进去
> 	printf("%s\t%d\t%f\n", s1.name, s1.age, s1.score);
> 
> 	fclose(pf);
> 	pf = NULL;
> 
> 	return 0;
> }
> ```

#### 输出流

|      功能      | 函数名  |   适用于   |
| :------------: | :-----: | :--------: |
|  字符输出函数  |  fputc  | 所有输出流 |
| 文本行输出函数 |  fputs  | 所有输出流 |
| 格式化输出函数 | fprintf | 所有输出流 |
| 二进制输出函数 | fwrite  |    文件    |

####   fputc

> **函数原型：**
>
> ```c
> int fputc( int c, FILE *stream );
> ```
>
> **函数简介：** 输出一个字符到一个文件内
>
> **参数一：** 要写入的字符
>
> **参数二：** 文件源
>
> **返回值：** 如果写入成功会返回输出的字符，如果写入失败返回`EOF`
>
> **使用案列：**
>
> ```c
> #define  _CRT_SECURE_NO_WARNINGS
> #include <stdio.h>
> #include <errno.h>
> #include <string.h>
> 
> 
> int main()
> {
> 	int ch = 0;
> 	FILE* pf = fopen("data.txt", "w");
> 	if (!pf)
> 	{
> 		printf("%s\n", strerror(errno));
> 
> 		return 1;
> 	}
> 
> 	ch = getchar();
> 	fputc(ch, pf);
> 	printf("%c", ch);
>     
> 	fclose(pf);
> 	pf = NULL;
> 
> 	return 0;
> }
> ```

#### fputs

> **函数原型：**
>
> ```c
> int fputs( const char *string, FILE *stream );
> ```
>
> **函数简介：** 用于向文件写入（输出）一个字符串
>
> **参数一：** 要输出的字符串
>
> **参数二：** 文件源
>
> **返回值：** 写入（输出）成功的话会返回一个非负值，写入失败会返回一个`EOF`
>
> **使用案例：**
>
> ```c
> #define  _CRT_SECURE_NO_WARNINGS
> #include <stdio.h>
> #include <errno.h>
> #include <string.h>
> 
> int main()
> {
> 	char* str = "Hello world";
> 	FILE* pf = fopen("data.txt", "w");
> 	if (!pf)
> 	{
> 		printf("%s\n", strerror(errno));
> 
> 		return 1;
> 	}
> 
> 	fputs(str, pf);
> 
> 	printf("%s\n", str);
> 
> 	fclose(pf);
> 	pf = NULL;
> 
> 	return 0;
> }
> ```



#### fprintf

> **函数原型：**
>
> ```c
> int fprintf( FILE *stream, const char *format [, argument ]...);
> ```
>
> **函数简介：** 向文件格式化写入（输出）一个字符串
>
> **参数一：** 源文件
>
> **参数二：** 字符串可以是格式化的
>
> **参数三：** 如果有格式要求需要给变量名
>
> **返回值：** 如果成功返回写入的字符宽度，如果失败返回一个`EOF`
>
> **使用案列：**
>
> ```c
> #define  _CRT_SECURE_NO_WARNINGS
> #include <stdio.h>
> #include <errno.h>
> #include <string.h>
> 
> typedef struct stu
> {
> 	char name[20];
> 	int age;
> 	float score;
> }stu;
> 
> int main()
> {
> 	stu s1 = { "张三", 25, 321.44f };
> 	FILE* pf = fopen("data.txt", "w");
> 	if (!pf)
> 	{
> 		printf("%s\n", strerror(errno));
> 
> 		return 1;
> 	}
> 
> 	fprintf(pf, "姓名：%s\n年龄：%d\n成绩：%.2f\n", s1.name, s1.age, s1.score);
> 
> 	fclose(pf);
> 	pf = NULL;
> 
> 	return 0;
> }
> ```



#### fwrite

> **函数原型：**
>
> ```c
> size_t fwrite( const void *buffer, size_t size, size_t count, FILE *stream );
> ```
>
> **参数一：** 任意类型要写入（输出）的地址
>
> **参数二：** 该任意类型的地址大小
>
> **参数三：** 向文件写入（输出）的个数
>
> **参数四：** 源文件
>
> **返回值：** ` Fwrite`返回实际写入的完整项数，如果发生错误，这个数可能小于`count`。此外，如果发生错误，则无法确定文件位置指示器。
>
> **使用案列：**
>
> ```c
> #include <string.h>
> 
> typedef struct stu
> {
> 	char name[20];
> 	int age;
> 	float score;
> }stu;
> 
> int main()
> {
> 	stu s1 = { "张三", 20, 352.55f };
> 	stu s2 = { 0 };
> 	FILE* pf = fopen("dataB.txt", "wb");
> 	if (!pf)
> 	{
> 		printf("%s\n", strerror(errno));
> 
> 		return 1;
> 	}
> 
> 	fwrite(&s1, sizeof(stu), 1, pf);
> 
> 	fclose(pf);
> 	pf = NULL;
> 
> 	return 0;
> }
> ```



### 格式化转换函数

#### sprintf

> **函数原型：**
>
> ```c
> int sprintf( char *buffer, const char *format [, argument] ... );
> ```
>
> **函数简介：** 把一个结构化数据转换为字符串，并存储该转换后的字符串。
>
> **参数一：** 字符串的存储源
>
> **参数二：** 转换的变量格式或者其它内容
>
> **参数三：** 需要用到的变量名，用于配对参数二的格式字符。
>
> **返回值：** 返回一个在文件缓冲区的字符个数，终止字符不算。
>
> **使用案列：**
>
> ```c
> #define _CRT_SECURE_NO_WARNINGS
> #include <stdio.h>
> 
> typedef struct stu
> {
> 	char name[20];
> 	int age;
> 	float score;
> }stu;
> 
> int main()
> {
> 	stu s1 = { "张三", 25, 300.55f };
> 	char buff[200] = { 0 };
> 
> 	//把结构化的数据转换为字符串，存储到buff里面
> 	sprintf(buff, "姓名：%s\t年龄：%d\t成绩：%.2f", s1.name, s1.age, s1.score);
> 	printf("%s\n", buff);
> 
> 
> 	return 0;
> }
> ```

#### sscanf

> **函数原型：**
>
> ```c
> int sscanf( const char *buffer, const char *format [, argument ] ... );
> ```
>
> **函数简介：** 把一个字符串抓换为一个结构化数据，并存储转换后的结构化数据。
>
> **参数一：** 字符串的转换源
>
> **参数二：** 该字符串拥有的类型格式
>
> **参数三：** 根据参数二的类型格式个数，对应的补充要存储的变量地址。
>
> **返回值：** 返回成功转换和分配的字段数量但不包括已读取但未分配的字段数量，返回0说明没有字段，如果出现错误或在第一次转换之前到达字符串的末尾，则返回值为`EOF`。
>
> **使用案列：**
>
> ```c
> #define _CRT_SECURE_NO_WARNINGS
> #include <stdio.h>
> 
> typedef struct stu
> {
> 	char name[20];
> 	int age;
> 	float score;
> }stu;
> 
> int main()
> {
> 	stu s1 = { "张三", 25, 300.55f };
> 	char buff[200] = { 0 };
> 
> 	//把结构化的数据转换为字符串，存储到buff里面
> 	sprintf(buff, "%s %d %.2f", s1.name, s1.age, s1.score);
> 	printf("%s\n", buff);
> 
> 	stu temp = { 0 };
> 	//把一个buff结构化后的字符串，转换为结构化数据存储到temp结构体变量里面
> 	sscanf(buff, "%s %d %f", temp.name, &(temp.age), &(temp.score));
> 	printf("姓名：%s\t年龄：%d\t成绩：%.2f\n", temp.name, temp.age, temp.score);
> 
> 	return 0;
> }
> ```



### 文件随机读写

#### fseek

> **函数原型：**
>
> ```c
> int fseek( FILE *stream, long offset, int origin );
> ```
>
> **函数简介：** 偏移当前指针文件的指向位置。
>
> **参数一：** 偏移的指针
>
> **参数二：** 偏移值
>
> **参数三：** 偏移方式：
>
> 1. **SEEK_SET**
>
>    从头部开始偏移
>
> 2. **SEEK_END**
>
>    从尾部开始偏移
>
> 3. **SEEK_CUR**
>
>    从当前位置开始偏移
>
> **返回值：** 如果成功，fseek返回0。否则，它返回一个非零值。在无法查找的设备上，返回值是未定义的。
>
> **使用案列：**
>
> ```c
> #define _CRT_SECURE_NO_WARNINGS
> #include <stdio.h>
> #include <string.h>
> #include <errno.h>
> 
> int main()
> {
> 	FILE* fp = fopen("data.txt", "r");
> 	if (!fp)
> 	{
> 		printf("%s\n", strerror(errno));
> 
> 		return 1;
> 	}
> 
> 	
> 	int ch = fgetc(fp);
> 	printf("%c\n", ch);
> 	ch = fgetc(fp);
> 	printf("%c\n", ch);
> 
> 	//当前位置开始偏移
> 	fseek(fp, 2, SEEK_CUR);
> 	ch = fgetc(fp);
> 	printf("%c\n", ch);
> 	fseek(fp, -1, SEEK_CUR);
> 	ch = fgetc(fp);
> 	printf("%c\n", ch);
> 
> 	//文件开头开始偏移
> 	fseek(fp, 1, SEEK_SET);
> 	ch = fgetc(fp);
> 	printf("%c\n", ch);
> 
> 	//文件末尾开始偏移
> 	fseek(fp, -1, SEEK_END);
> 	ch = fgetc(fp);
> 	printf("%c\n", ch);
> 
> 	return 0;
> }
> ```

#### ftell

> **函数原型：**
>
> ```c
> long ftell( FILE *stream );
> ```
>
> **函数简介：** 用于查看当前文件指针离开头的偏移量。
>
> **参数一：** 文件指针
>
> **返回值：** 返回偏移量
>
> **使用案例：**
>
> ```c
> #define _CRT_SECURE_NO_WARNINGS
> #include <stdio.h>
> #include <string.h>
> #include <errno.h>
> 
> int main()
> {
> 	FILE* fp = fopen("data.txt", "r");
> 	if (!fp)
> 	{
> 	
>      	printf("%s\n",strerror(errno));
> 
> 		return 1;
> 	}
> 	
> 	//文件末尾开始偏移
> 	fseek(fp, -1, SEEK_END);
> 	//返回一个偏移量
> 	int count = ftell(fp);
> 	ch = fgetc(fp);
> 	printf("%c %d\n", ch, count);
> 
> 	return 0;
> }
> ```

#### rewind

> **函数原型：**
>
> ```c
> void rewind( FILE *stream );
> ```
>
> **函数简介：** 让文件指针回到文件起始位置
>
> **参数一：** 需要调整的文件指针
>
> **返回值：** 无
>
> **使用案列：**
>
> ```c
> #define _CRT_SECURE_NO_WARNINGS
> #include <stdio.h>
> #include <string.h>
> #include <errno.h>
> 
> int main()
> {
> 	int ch = 0;
> 	FILE* fp = fopen("data.txt", "w");
> 	if (!fp)
> 	{
> 		printf("%s\n", strerror(errno));
> 
> 		return 1;
> 	}
> 
> 	int count = 0;
> 
> 	while (count < 10)
> 	{
> 		fputc('a' + count, fp);
> 		count++;
> 	}
> 
> 	//偏移到文件开始进行写入
> 	rewind(fp);
> 
> 	fputs("666", fp);
> 
> 	fclose(fp);
> 	fp = NULL;
> 
> 	return 0;
> }
> ```



### 文件错误检查

#### feof

> **函数原型：**
>
> ```c
> int feof( FILE *stream );
> ```
>
> **函数简介：** 测试流上的文件是否是遇到结束符正常结束
>
> **参数一：** 文件指针
>
> **返回值：** 如果正常结束返回一个真，如果不是正常结束返回一个假。
>
> **使用例子：**
>
> ```c
> #define _CRT_SECURE_NO_WARNINGS
> #include <stdio.h>
> #include <string.h>
> #include <errno.h>
> 
> int main()
> {
> 	int ch = 0;
> 	FILE* fp = fopen("data.txt", "r");
> 	if (!fp)
> 	{
> 		printf("%s\n", strerror(errno));
> 
> 		return 1;
> 	}
> 
> 	while (~(ch = fgetc(fp)))
> 	{
> 		printf("%c", ch);
> 	}
> 
> 	//如果正常读取完结束会返回一个真
> 	if (feof(fp))
> 	{
> 		printf("正常结束\n");
> 	}
> 
> 	return 0;
> }
> ```

#### ferrof

> **函数原型：**
>
> ```c
> int ferror( FILE *stream );
> ```
>
> **函数简介：** 测试I/O流是否是正常结束
>
> **参数一：** 文件指针
>
> **返回值：** 如果I/O流没有读取错误会返回一个0，如果读取错误会返回一个非零值
>
> **使用案列：**
>
> ```c
> #define _CRT_SECURE_NO_WARNINGS
> #include <stdio.h>
> #include <string.h>
> #include <errno.h>
> 
> int main()
> {
> 	int ch = 0;
> 	FILE* fp = fopen("data.txt", "r");
> 	if (!fp)
> 	{
> 		printf("%s\n", strerror(errno));
> 
> 		return 1;
> 	}
> 
> 	while (~(ch = fgetc(fp)))
> 	{
> 		printf("%c", ch);
> 	}
> 
> 	//如果正常读取完结束会返回一个真
> 	if (feof(fp))
> 	{
> 		printf("正常结束\n");
> 	}
> 	//如果读取没错误会返回一个0，如果读取错误会返回也给非零值
> 	else if (ferror(fp))
> 	{
> 		printf("I/O流读取错误\n");
> 	}
> 
> 	return 0;
> }
> ```

**总结：** 这两个函数不能直接判断文件的错误，只能帮你排除读取错误和非正常结束。

# 预处理

### 程序生成过程

![image-20220201195054623](https://picturestorage1.oss-cn-shenzhen.aliyuncs.com/c%E7%AC%94%E8%AE%B0/image-20220201195054623.png)



### 预处理指令

#### #define

> `#define`用于给一个值重新定义名字
>
> **使用案列：**
>
> ```c
> #define INT_MAX 1024
> 
> //INT_MAX和1024等价
> ```

#### 宏定义

> `#define`可以定义一个宏，该宏可以附带参数。
>
> ```c
> #include <stdio.h>
> 
> #define SQUARE(X) ((X) * (X))
> 
> int main()
> {
> 	int x = 100;
> 
> 	int ret = SQUARE(x);
> 
> 	printf("%d\n", ret);
> 
> 	return 0;
> }
> ```



#### 宏函数

> 宏定义可以定义出来的东西，可以像函数一样使用所以叫宏函数，本质还是一个宏定义。
>
> **使用案列：**
>
> ```c
> #define MAX(X,Y) ((X) > (Y) ? (X) : (Y))
> ```



#### 宏函数和函数的区别

|    区别    | 函数 | 宏定义 |
| :--------: | :--: | :----: |
| 小任务效率 |  低  |   高   |
|  类型检查  |  有  |   无   |
|    调试    | 支持 | 不支持 |
| 优先级问题 |  无  |   有   |

### 条件编译

#### #ifdef

> **使用案列：**
>
> ```c
> #include <stdio.h>
> 
> #define __ADD_H__
> 
> int main()
> {
> #ifdef __ADD_H__//如果定义过就执行以下内容
> 	//...
> #endif
> 
> 	return 0;
> }
> ```



#### #ifndef

> 一般用于防止头文件重复包含
>
> **使用案列：**
>
> ```c
> //如果未定义就执行，一旦执行就会定义一个，下次再包含此头文件那么将不会重复包含
> #ifndef __ADD_H__
> #define __ADD_H__
> 
> extern int ADD(int a, int b);
> #endif // !__ADD_H__
> ```



### 条件判断

#### #if

> 可以像分支语句一样使用，不过使用的场景区别很大。
>
> **使用案列：**
>
> ```c
> #include <stdio.h>
> 
> int main()
> {
> 
> 	//如果表达式为真就执行以下内容，如果为假则不执行，支持嵌套、多分支和单分支。
> #if 3
> 	//...
> #elif 3 - 3
> 	//...
> #else
> 	//...
> #endif
> 
> 	return 0;
> }
> ```
>
> 

### 头文件的搜索方式

#### ""

> 在当前工程的路径内搜索，一般用于包含自定义的函数。

#### <>

> 一般用于搜索系统默路径官方库文件，如果使用的是官方库那么必须用`<>`来包含，否则找不到该头文件。

# 🎎🎎🎎左值与右值

### 左值

#### 什么是左值？

> 左值是容器可写入（修改）的，一般都是变量充当左值。

### 右值

#### 什么是右值？

> 右值是数据，一般变量和常量来充当右值。

**总结：** 左值是容器，右值是数据，右值大部分是不可修改的，而左值必须是可修改的。



